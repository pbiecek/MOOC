---
title: "Cechy jakościowe"
author: "pogRomcy danych"
date: "sezon 1 / odcinek 12 <br><br> Wszelkie prawa zastrzeżone.<br> Wykorzystanie możliwe wyłącznie za zgodą autora.  <br><br><br><br>Naciśnij `A` by zamienić slajdy na ciągły tekst. <br> Naciśnij `T` by wyświetlić spis treści."
output:
  slidy_presentation:
    includes:
      in_header: ../tracking.html
    highlight: default
    css: ../style.css
    font_adjustment: 0
    footer: "pogRomcy danych / przetwarzanie / zmienne jakościowe"

---

Analizując dane spotkamy się z różnymi rodzajami zmiennych. Bardzo często spotykane są cechy jakościowe. Są też sytuacje w których warto cechę ilościową przekształcić w jakościową. 

W tym odcinku nauczymy się

- Jakie zmienne / cechy określa się terminem *cechy jakościowe*?
- Jakie podstawowe operacje można wykonywać na cechach jakościowych?
- Jak podsumowywać / opisywać cechy jakościowe?

Do ilustracji tych zagadnień wykorzystamy dwa zbiory danych. Pierwszy, mały zbiór danych, to `koty_ptaki` a drugi, znacznie większy, to `auta2012`, oba dostępne w pakiecie `SmarterPoland`.

---

# Co to znaczy: cecha jakościowa

Cechy jakościowe to takie, które opisują przynależność do grup. Z tego powodu, często stosuje się też nazwę *zmienna grupująca*. A ponieważ w programie R taką zmienną oznacza się terminem `factor`, to w języku polskim spotyka się kalkę *zmienna faktor*. Inną stosowaną, często przez programistów, nazwą jest *zmienna czynnikowa*.

Określając zmienną jakościową warto wskazać o jakich grupach mówimy, przykłądami zmiennych jakościowych jest np. wykształcenie (grupy: podstawowe, średnie, wyższe), płeć (grupy: kobieta, męższczyzna), kraj zamieszkania (grupy: Polska, ...).

Zmienna jakościowa może być opisana liczbami, jeżeli jednak te liczby nie oznaczają ilosći to taka zmienna będzie zmienną jakościową. Przykładowo pierwsze dwie cyfry kodu ZIP mogą być zmienną jakościową, ocenę szkolną można traktować jako zmienną jakościową (można też jako ilościową zależnie od kontekstu), podobnie liczba drzwi samochodu, jeżeli chcemy jej użyć do pogrupowania samochodów na 3 i 5 drzwiowe, potraktujemy tę liczbę jako cechę jakościową.

Jakkolwiek zmienne jakościowe mogą bardzo różnić się liczbą grup oraz rodzajem grup, można na nich wykonywać kilka wspólnych operacji. Przyjrzyjmy się im.

---

# Wczytanie danych

Dane od których rozpoczniemy przykłady to `koty_ptaki` z pakietu `SmarterPoland`. Aby te dane wczytać, wystarczy włączyć ten pakiet, instrukcja jak to zrobić znajduje się w odcinku 2.

Włączmy pakiet i użyjmy funkcji `head()` by wyświetlić pierwsze sześć wierszy. Które z tych zmiennych to zmienne jakościowe?

```{r, warning=FALSE, message=FALSE}
library(SmarterPoland)
head(koty_ptaki)
```

Każdy wiersz opisuje jeden gatunek. Zmienne jakośćiowe to w poniższym przypadku wszystkie te, które nei są liczbowymi, a więc gatunek, habitat i drużyna.

---

# Cechy jakościowe

Przyjrzyjmy się dwóm z tych zmiennych, gatunek i drużyna.

```{r}
koty_ptaki$gatunek
koty_ptaki$druzyna
```

Gdy te zmienne są wyświetlane, poza wartościami dodatkowo wyświetlany jest zbiór wszystkich możliwych wartości.
Ten zbiór nazywa się najczęściej poziomami zmiennej jakościowej lub słownikiem zmiennej.

Dwie podstawowe operacje na zmiennych jakościowych to odczytywanie poziomów zmiennej, co można zrobić funkcją `levels()` oraz wyznaczanie liczebności poszcezgólnych poziomów, co można wykonać funkcją `table()`.

To czy dana zmienna jest zmienną jakościową czy ilośćiową można sprawdzić używając funkcji `class()`. Jeżeli wynikiem jest napis `factor` to mamy do czynienia ze zmienną jakosciową. Jeżeli wnikiem jest `integer` lub `numeric` to mamy do czynienia ze zmienną ilościową.

```{r}
class(koty_ptaki$druzyna)
class(koty_ptaki$predkosc)
class(koty_ptaki$dlugosc)
```

---

# Cechy jakościowe

Przykładowo dla dwóch wybranych zmiennych ze zbioru `koty_ptaki` otrzymujemy takie wyniki dla obu funkcji.

Wynikiem funkcji `levels()` jest wektor napisów - poziomów zmiennej jakościowej.

```{r}
levels(koty_ptaki$gatunek)
levels(koty_ptaki$druzyna)
```

Wynikiem funkcji `table()` jest wektor liczebności każdego czynnika.

```{r}
table(koty_ptaki$gatunek)
table(koty_ptaki$druzyna)
```

Obie zmienne znacznie się różnią. Drużyna występuje tylko w dwóch wartościach a gatunek w trzynastu (każdy wiersz to inna wartość).

---

# Wczytanie danych

Zbiór danych `koty_ptaki` składa się z 13 wierszy. Można cały ten zbiór danych wyświetlić na ekranie. Nie zawsze potrzebujemy więc specjalnych statystyk opisowych by zrozumieć co się dzieje w takich małych zbiorach danych.

Dlatego, dalsze ćwiczenia ze zmiennymi ilościowymi przeprowadzimy na znaczeni większym zbiorze danych z ponad 200 tysiącami wartości, o nazwie `auta2012`, który znajduje się również w pakiecie `SmarterPoland`.

Opis tego zbioru danych znaleźć można w odcinku https://rawgit.com/pbiecek/MOOC/master/0_dane/0_dane.html

Wczytajmy ten zbiór danych i przyjrzyjmy się dwóm pierwszym wierszom. 

```{r, warning=FALSE, message=FALSE}
library(SmarterPoland)
head(auta2012, 2)
```

Które z tych zmiennych to zmienne jakościowe?

---

# Statystyki opisowe

Przyjrzyjmy się teraz takim cechom jak `Waluta` lub `Marka`. Cechy te są opisane przez wartości z określonej listy możliwości.
Dla cechy `Waluta` lista możliwości to `levels(auta2012$Waluta)`=`r levels(auta2012$Waluta)`.

Dla cech jakościowych możemy wykonać kilka operacji.
Jedną z nich jest wyświetlenie listy możliwych wartości. Taką listę nazywa się często słownikiem (spisem możliwych wartości).

Listę możliwych wartości dla zmiennej jakościowej można wyznaczyć funkcją `levels()`.

```{r, warning=FALSE}
levels(auta2012$Waluta)
```

Zmienne jakościowe często opisuje się tablicą liczebności, a więc informacją ile razy wystąpiła każda z wartości ze słownika.
Tablicę liczebności można wyznaczyć funkcją `table()` lub `summary()`. Jeżeli w zmiennej jakościowej występują wartości brakujące, to funkcja `summary()` też napisze ile ich jest.

```{r, warning=FALSE}
table(auta2012$Waluta)
summary(auta2012$Waluta)
```

---

# Zadania:

+ Ile zmiennych w zbiorze danych `auta2012` to zmienne jakościowe? 

+ Zmienna `Liczba.drzwi` przyjmuje wartości `2/3` i `4/5`. Zachowuje się ona jako zmienna jakościowa. Jednak można uznać, że liczba drzwi to cecha ilościowa, ponieważ opisuje _ilość_ drzwi w samochodzie. Jak wyjaśnić tę dualność?

Przykładowe odpowiedzi znajdują się na stronie https://rawgit.com/pbiecek/MOOC/master/0_dane/9_zadania.html

---

# Procenty

W pewnych sytuacjach, zamiast posługiwać się tablicą liczebności, wygodniej jest posługiwać się tabelą z procentami.

Ale jak te procenty policzyć?

Można to zrobić na kilka sposobów. Funkcja `prop.table()` dzieli wartości tabeli liczebności przez sumę liczebności, a więc zamienia liczebności na frakcje.
Przypiszmy wynik funkcji `table()` do jakiejś zmiennej, np. o nazwie `waluty` (nazwa może być dowolna, musimy jej jednak konsekwentnie używać w dalszych przykładach).
Następnie tak otrzymaną tabelę liczebności zamieniamy na frakcje.

W poniższym przykładzie, instrukcję przypisania wyniku obejmujemy napisami, po to by jej wynik był wyświetlony. Bez nawiasów wynik funkcji `table()` nie zostałby wyświetlony.

```{r, warning=FALSE}
(waluty <- table(auta2012$Waluta))
prop.table(waluty)
```

---

# Procenty

Funkcja `prop.table()` wyznacza frakcje, ale nie wyglądają one zbyt czytelnie dla człowieka. Wygodniej by było wypisać procenty. I to nie byle jakie procenty, ale procenty które są ładnie sformatowane, np. wyświetlone z dokładnością do jednego miejsca dziesiętnego po przecinku.

Aby zamienić frakcje na procenty, wystarczy je przemnożyć przez 100, a aby wynik przedstawić z dokładnością do jednego miejsca po przecinku wykorzystamy funkcję `round()`, która zaokrągla liczby do wskazanej liczby miejsc po kropce dziesiętnej.

```{r, warning=FALSE}
waluty <- table(auta2012$Waluta)
(frakcje <- prop.table(waluty))
(procenty <- 100*frakcje)
round(procenty, digits = 1)
```

 Wszystkie przedstawione powyżej operacje działają i na pojedynczych wartościach (nazywanych skalarami) jak i na wektorach. Przykładowo operacja `100*frakcje` wymnaża liczbę `100` z każdym elementem wektora `frakcje` i wynikiem tej operacji jest wektor. Nie w każdym języku programowania można mieć takie mieszane operacje mnożenia wektorów i skalarów.

---

# Procenty posortowane

Mamy już procenty. Aby dodatkowo zwiększyć czytelność tej formy prezentacji warto te procenty posortować rosnąco lub malejąco.

Nawet dla ośmiu liczb, jeżeli każda z nich jest opisana przez wiele cyfr, czasem w gąszczu cyfr trudno nawet dostrzec, która jest największa.

Do sortowania można wykorzystać funkcję `sort()`. Dodając argument `decreasing = TRUE` powodujemy, że wartości będą uporządkowane malejąco.

```{r, warning=FALSE}
zaokragloneProcenty <- round(procenty,1)
sort(zaokragloneProcenty)
sort(zaokragloneProcenty, decreasing = TRUE)
```

---

# Procenty posortowane

Wartości w wektorze można posortować też na kilka innych sposobów. 
Bardziej skomplikowanym, ale pozwalającym na omówienie bardziej zaawansowanych przykładów indeksowania jest funkcja `order()`.

Wynikiem funkcji `order()` są indeksy elementów w wektorze które tworzą ciąg rosnący. Więcej informacji o tej funkcji znaleźć można w odcinku 7.

```{r, warning=FALSE}
order(zaokragloneProcenty)
```

Jeżeli wektor `zaokragloneProcenty` będziemy czytać w kolejności, pierwszy element, trzeci, piąty, szósty, ósmy, czwarty, drugi i siódmy, to otrzymamy posortowany ciąg.

Możemy więc wynik tej funkcji wykorzystać do indeksowania oryginalnego zbioru danych, i w ten sposób posortować cały wektor.

```{r, warning=FALSE}
kolejnoscPosortowanych <- order(zaokragloneProcenty)
zaokragloneProcenty[kolejnoscPosortowanych]
```

A jak sprawdzić, na których pozycjach występują trzy najmniejsze wartości?

```{r, warning=FALSE}
kolejnoscPosortowanych[1:3]
```

---

# Zadania:

+ Cecha `Marka` opisuje markę samochodu. Sprawdź, która marka jest najpopularniejsza.

+ Cecha `Rodzaj.paliwa` opisuje rodzaj paliwa wykorzystywanego przez auto. Czy jest to benzyna, olej, gaz? Sprawdź jaki procent samochodów jest napędzana na benzynę.

Przykładowe odpowiedzi znajdują się na stronie https://rawgit.com/pbiecek/MOOC/master/0_dane/9_zadania.html

---

# Graficzne statystyki opisowe

Tabele liczebności są proste w interpretacji. Podobnie jednak jak w innych przypadkach, graficzne przedstawienie tych liczb pozwala na łatwiejsze dostrzeżenie co się dzieje z danymi. Koniec końców w tabeli liczb łatwo pomylić się nawet gdy chodzi o liczbę cyfr w liczbie. Na wykresie takie wartości natychmiast rzucają się w oczy.

Zazwyczaj tabele liczebności przedstawia się za pomocą wykresów słupkowych.
Wykresy słupkowe można wykonać np. funkcją `barplot()`.

```{r, warning=FALSE, fig.width=5, fig.height=5}
(waluty <- table(auta2012$Waluta))
barplot(waluty)
```

---

# Graficzne statystyki opisowe

Jeżeli chcemy, by słupki były przedstawiane poziomo, do funckji `barplot()` można dodać argument `horiz = TRUE`.

Domyślnie wartości są uporządkowane alfabetycznie. Nie zawsze jednak taka kolejność ma sens.
W tym przypadku rozsądniej jest posortować dane malejąco, co można wykonać z użyciem funkcji `sort()`.

Argument `las=1` powoduje, że oś OY ma etykiety ustawione poziomo.

```{r, warning=FALSE, fig.width=5, fig.height=5}
posortowaneWaluty <- sort(waluty)
barplot(posortowaneWaluty, horiz = TRUE, las=1)
```

---

# Zadania:

+ Przedstaw graficznie tabelę liczebności dla zmiennej `Kraj.pochodzenia`. 

Wypróbuj wykres pionowy i poziomy. 

Aby obrócić kierunek etykiet na osiach dodaj do funkcji `barplot()` argument `las=1`.

Przykładowe odpowiedzi znajdują się na stronie https://rawgit.com/pbiecek/MOOC/master/0_dane/9_zadania.html

---

# Napisy czy czynniki?

Z wyglądu, cechy jakościowe (czynniki) przypominają cechy napisowe. 
Jednak pod spodem, ich reprezentacja jest zupełnie inna.
Czynniki nie są pamiętane jako napisy, ale jako para - wektor liczb i słownik, określający, który napis odpowiada, której liczbie. Dzięki temu można zaoszczędzić pamięć przy przechowywaniu dużych zbiorów danych. 

Na napisach zazwyczaj wykonuje się inne operacje niż na zmiennych jakościowych, może się więc tak zdarzyć, że celowo chcemy jakieś dane odczytać jako napisy. Ale ddy dane są wczytywane z pliku tekstowego w którym są napisy, domyślnie napisy są wczytywane jako czynniki. 

W poniższym przykładzie, takie zmienne jak `gatunek` i `habitat` są wczytywane jako zmienna klasy `factor`. Efektem ubocznym jest sposób wyświetlania wyników np. przez zmienną `cat()`. Dla zmiennej czynnikowej, ta funkcja na ekranie wypisze liczby a nie wartości napisowe. 

```{r, warning=FALSE, fig.height=8}
koty_ptaki <- read.table("http://biecek.pl/MOOC/dane/koty_ptaki.csv", 
          sep=";", dec=",", header=TRUE)
str(koty_ptaki)
class(koty_ptaki$gatunek)
cat(koty_ptaki$gatunek)
```

---

# Napisy czy czynniki?

Funkcja `read.table()` posiada argument `stringsAsFactors` określający w jaki sposób wczytywać kolumny z napisami. Ustawiwszy argument `stringsAsFactors=FALSE` wymuszamy wczytywanie danych jako zmienne napisowe. Zajmie to trochę więcej pamięci, ale samo wczytywanie będzie trochę szybsze. 

Zauważmy jak teraz wygląda wynik funkcji `str()` i `cat()`.

```{r, warning=FALSE, fig.height=8}
koty_ptaki <- read.table("http://biecek.pl/MOOC/dane/koty_ptaki.csv", 
          sep=";", dec=",", header=TRUE, stringsAsFactors=FALSE)
str(koty_ptaki)
class(koty_ptaki$gatunek)
cat(koty_ptaki$gatunek)
```

Tym razem kolumna `gatunek` została wczytana jako wetkor napisów. 

---

# Napisy czy czynniki?

Zmienne czynnikowe można konwertować na napisy funkcją `as.character()`.

Napisy można konwertować na zmienne czynnikowe funkcją `as.factor()`. 

Przedstawmy działanie obu funkcji na przykładzie.

```{r, warning=FALSE, fig.height=8}
czynniki <- as.factor(koty_ptaki$gatunek)
str(czynniki)
napisy <- as.character(czynniki)
str(napisy)
```
---

# Tablice częstości

A co gdybyśmy chcieli przedstawić zależność pomiędzy dwoma zmiennymi jakościowymi? Można to zrobić używając funkcji `table()` (należy kolejne zmienne podawać jako kolrjne argumenty) ale można też użyć funkcją `xtabs()`, która jest trochę wygodniejsza w pracy.

Pierwszym argumentem tej funkcji jest formuła o składni `~ zmienna_1 + .. + zmienna_n`, t.j. rozpoczynająca się tyldą a następnie ze zmiennymi porozdzielanymi znakiem plusa. Drugim argumentem jest ramka danych, która powinna zawierać zmienne wymienione w formule. 

Wynikiem jest tablica kontyngencji o tylu wymiarach, ile zmiennych występuje w formule.

Przykładowo, zestawiając ze sobą kraj pochodzenia oraz walutę w ogłoszeniu, otrzymujemy tablicę częstości o wymiarach 32 wiersze i 8 kolumn. Pierwszy wiersz tej tabeli odpowiada pusterj wartości kraju pochodzenia, stąd brak nazwy w pierwszym wierszu.

```{r, warning=FALSE, fig.height=8}
(krajWaluta <- xtabs( ~ Kraj.pochodzenia + Waluta, auta2012))
```

---

# Tablice częstości

Tablice częstości nie są ramkami danych. 

Gdy w grę wchodzą dwie zmienne, to wyglądają jak ramki danych, mają wiersze i kolumny. Muszą być jednak czymś innym, ponieważ w sytuacji, gdy tablica kontyngencji dotyczy trzech lub większej liczby zmiennych to wynikowa macierz kontyngencji ma więcej wymiarów niż dwa. 

Funkcją `as.data.frame` można przekształcić wielowymairowe tabele do ramki danych. Otrzyma się w tym przypadku tak zwaną reprezentację rzadką macierzy kontyngencji, w której pierwsze kolumny opisują wszystkie kombinacje czynników zmiennych a ostania kolumna opisuje liczebność występowania poszczególnej kombinacji czynników.

```{r, warning=FALSE, fig.height=8}
xt <- xtabs(~Kraj.pochodzenia+Waluta, auta2012)
xt <- as.data.frame(xt)
xt[xt$Freq > 0, ]
```

---

# Przekształcanie zmiennych ilościowych w jakościowe

Opisując dane ilościowe, często można ułątwić ich zrozumienie, jeżeli zmienne ilościowe podzieli się na przedziały. Takie przedziały są już zmienną jakościową.

Zmienną jakościową z ilościowej można stworzyć używając funkcji `cut()`, która za prierwszy argument przyjmuje zmienną ilościową a za drugi przyjmuje liczbę przedziałów do zbudowania lub punkty odcięcia dla tych przedziałów.

W przedziale poniżęj przekształcimy zmienną `waga` ze zbioru `koty_ptaki` na cztery przedziały, 0-1, 1-10, 10-100 i 100-1000. Tak stworzoną zmienną dodamy do zbioru `koty_ptaki` pod nazwą `wagaKategoria`.

```{r, warning=FALSE, fig.height=8}
koty_ptaki$waga
koty_ptaki$wagaKategoria <- cut(koty_ptaki$waga, c(0,1,10,100,1000))
table(koty_ptaki$wagaKategoria)
```
---

# Tablice częstości

Wykorzystajmy tą nowo utworzoną zmienną do przedstawienia graficznych statystyk dla pary zmiennych jakościowych.

Zestawimy wagę ze zmienną drużyna. A następnie tę dwuwymiarową tabelę przekażemy do funkcji `mosaicplot()`. 

Rysuje ona tak zwany wykres mozaikowy przedstawiający jednocześnie wiele zależności. W pierwszym kroku szerokość kolumn odpowiada proporcjom wartości Kot i Ptak w zbiorze danych (jest ich prawie po równo, dlatego obie kolumny mają dosyć podobną szeorkość). Następnie wysokość wierszy odpowiada względnemu udziałowi poszcezgólnych wartości w określonej kolumnie. W kolumnie Kot dominuje przedział dla wagi 10-100, a w kolumnie Ptak dominuj eprzedział 1-10 oznaczony kolorem niebieskim. 

Jest to sposób na przedstawienie rozkładów warunkowych. Bardzo użyteczne, jednak wymagające pewnej wprawy w czytaniu. Więcej o wykresach mozaikowych i innych metodach przedstawiania dwóch zmiennych jakościowych znaleźć można w sezonie 3.

```{r, warning=FALSE, fig.height=5, fig.height=5}
(druzynaWaga <- xtabs(~druzyna + wagaKategoria, koty_ptaki))

mosaicplot(druzynaWaga, las=2, col=c("green", "blue", "grey", "black"))
```

---

# Kolejność i nazwy czynników

Domyślna kolejność czynników, to kolejność leksykograficzna. 
Tworząc wykresy, zazwyczaj wartości prezentowane są zgodnie z kolejnością opisaną przez atrybut `levels`.

```{r, warning=FALSE, fig.height=5, fig.width=5}
levels(auta2012$Rodzaj.paliwa)
boxplot(Rok.produkcji ~ Rodzaj.paliwa, auta2012, las=2)
```

---

# Kolejność i nazwy czynników

Domyślną kolejność można  zmienić. 

Jednym ze sposobów określania kolejności czynników jest argument `levels` w funkcji `factor()`. Czynniki będą mieć kolejność zgodną z tam wskazaną.

```{r, warning=FALSE, fig.height=8}
levels(auta2012$Skrzynia.biegow)
auta2012$Skrzynia.biegow <- factor(auta2012$Skrzynia.biegow, levels=c("manualna","", "automatyczna"))
```

---

# Kolejność i nazwy czynników

Jeżeli chcemy ,,posortować'' poziomy zgodnie z pewną cechą ilościową, to wygodne będzie użycie funkcji `reorder()`. Jako argumenty pobiera ona wektor ze zmienną czynnikową, wektor z dowolną zmienną i funkcję. Dla każdej grupy określonej przez zmienną czynnikową, wartości wskazanych przez drugi argument, wyznaczana jest wartość funkcji - trzeciego argumentu. Następnie czynniki są porządkowane zgodnie z kolejnością wyników trzeciej funkcji.

W przykładzie poniżej, rodzaje paliwa są porządkowane zgodnie ze średnim rokiem produkcji aut o określonym rodzaju paliwa.

```{r, warning=FALSE, fig.height=8}
auta2012$Rodzaj.paliwa.posortowany <- reorder(auta2012$Rodzaj.paliwa, auta2012$Rok.produkcji, mean)

boxplot(Rok.produkcji ~ Rodzaj.paliwa.posortowany, auta2012, las=2)
```

---

# Kolejność i nazwy czynników

Nazwy czynników można też dowolnie zmieniać.

Najprościej można to zrobić używając funkcji `levels<-()` tak jak na poniższym przykładzie.

```{r, warning=FALSE, fig.height=8}
levels(auta2012$Rodzaj.paliwa)

levels(auta2012$Rodzaj.paliwa) <- c("", "B", "B+C", "B+L", "E", "H", "I", "L", "D", "W")
table(auta2012$Rodzaj.paliwa)
```
