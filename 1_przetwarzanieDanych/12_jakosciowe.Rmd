---
title: "Cechy jakościowe"
author: "pogRomcy danych"
date: "sezon 1 / odcinek 12 <br><br> Wszelkie prawa zastrzeżone.<br> Wykorzystanie możliwe wyłącznie za zgodą autora.  <br><br><br><br>Naciśnij `A` by zamienić slajdy na ciągły tekst. <br> Naciśnij `T` by wyświetlić spis treści."
output:
  slidy_presentation:
    includes:
      in_header: ../tracking.html
    highlight: default
    css: ../style.css
    font_adjustment: 0
    footer: "pogRomcy danych / przetwarzanie / zmienne jakościowe"

---

Analizując dane spotkamy się z różnymi rodzajami zmiennych. Bardzo często spotykane są cechy jakościowe. Są też sytuacje w których warto cechę ilościową przekształcić w jakościową. 

W tym odcinku nauczymy się

- Jakie zmienne / cechy określa się terminem *cechy jakościowe*?
- Jakie podstawowe operacje można wykonywać na cechach jakościowych?
- Jak podsumowywać / opisywać cechy jakościowe?

Do ilustracji tych zagadnień wykorzystamy dwa zbiory danych. Pierwszy, mały zbiór danych, to `koty_ptaki` a drugi, znacznie większy, to `auta2012`, oba dostępne w pakiecie `SmarterPoland`.

---

# Co to znaczy: cecha jakościowa

Cechy jakościowe to takie, które opisują przynależność do grup. Z tego powodu, często stosuje się też nazwę *zmienna grupująca*. A ponieważ w programie R taką zmienną oznacza się terminem `factor`, to w języku polskim spotyka się kalkę *zmienna faktor*. Inną stosowaną, często przez programistów, nazwą jest *zmienna czynnikowa*.

Określając zmienną jakościową warto wskazać o jakich grupach mówimy, przykłądami zmiennych jakościowych jest np. wykształcenie (grupy: podstawowe, średnie, wyższe), płeć (grupy: kobieta, męższczyzna), kraj zamieszkania (grupy: Polska, ...).

Zmienna jakościowa może być opisana liczbami, jeżeli jednak te liczby nie oznaczają ilosći to taka zmienna będzie zmienną jakościową. Przykładowo pierwsze dwie cyfry kodu ZIP mogą być zmienną jakościową, ocenę szkolną można traktować jako zmienną jakościową (można też jako ilościową zależnie od kontekstu), podobnie liczba drzwi samochodu, jeżeli chcemy jej użyć do pogrupowania samochodów na 3 i 5 drzwiowe, potraktujemy tę liczbę jako cechę jakościową.

Jakkolwiek zmienne jakościowe mogą bardzo różnić się liczbą grup oraz rodzajem grup, można na nich wykonywać kilka wspólnych operacji. Przyjrzyjmy się im.

---

# Wczytanie danych

Dane od których rozpoczniemy przykłady to `koty_ptaki` z pakietu `SmarterPoland`. Aby te dane wczytać, wystarczy włączyć ten pakiet, instrukcja jak to zrobić znajduje się w odcinku 2.

Włączmy pakiet i użyjmy funkcji `head()` by wyświetlić pierwsze sześć wierszy. Które z tych zmiennych to zmienne jakościowe?

```{r, warning=FALSE, message=FALSE}
library(SmarterPoland)
head(koty_ptaki)
```

Każdy wiersz opisuje jeden gatunek. Zmienne jakośćiowe to w poniższym przypadku wszystkie te, które nei są liczbowymi, a więc gatunek, habitat i drużyna.

---

# Cechy jakościowe

Przyjrzyjmy się dwóm z tych zmiennych, gatunek i drużyna.

```{r}
koty_ptaki$gatunek
koty_ptaki$druzyna
```

Gdy te zmienne są wyświetlane, poza wartościami dodatkowo wyświetlany jest zbiór wszystkich możliwych wartości.
Ten zbiór nazywa się najczęściej poziomami zmiennej jakościowej lub słownikiem zmiennej.

Dwie podstawowe operacje na zmiennych jakościowych to odczytywanie poziomów zmiennej, co można zrobić funkcją `levels()` oraz wyznaczanie liczebności poszcezgólnych poziomów, co można wykonać funkcją `table()`.

To czy dana zmienna jest zmienną jakościową czy ilośćiową można sprawdzić używając funkcji `class()`. Jeżeli wynikiem jest napis `factor` to mamy do czynienia ze zmienną jakosciową. Jeżeli wnikiem jest `integer` lub `numeric` to mamy do czynienia ze zmienną ilościową.

```{r}
class(koty_ptaki$druzyna)
class(koty_ptaki$predkosc)
class(koty_ptaki$dlugosc)
```

---

# Cechy jakościowe

Przykładowo dla dwóch wybranych zmiennych ze zbioru `koty_ptaki` otrzymujemy takie wyniki dla obu funkcji.

Wynikiem funkcji `levels()` jest wektor napisów - poziomów zmiennej jakościowej.

```{r}
levels(koty_ptaki$gatunek)
levels(koty_ptaki$druzyna)
```

Wynikiem funkcji `table()` jest wektor liczebności każdego czynnika.

```{r}
table(koty_ptaki$gatunek)
table(koty_ptaki$druzyna)
```

Obie zmienne znacznie się różnią. Drużyna występuje tylko w dwóch wartościach a gatunek w trzynastu (każdy wiersz to inna wartość).

---

# Wczytanie danych

Zbiór danych `koty_ptaki` składa się z 13 wierszy. Można cały ten zbiór danych wyświetlić na ekranie. Nie zawsze potrzebujemy więc specjalnych statystyk opisowych by zrozumieć co się dzieje w takich małych zbiorach danych.

Dlatego, dalsze ćwiczenia ze zmiennymi ilościowymi przeprowadzimy na znaczeni większym zbiorze danych z ponad 200 tysiącami wartości, o nazwie `auta2012`, który znajduje się również w pakiecie `SmarterPoland`.

Opis tego zbioru danych znaleźć można w odcinku https://rawgit.com/pbiecek/MOOC/master/0_dane/0_dane.html

Wczytajmy ten zbiór danych i przyjrzyjmy się dwóm pierwszym wierszom. 

```{r, warning=FALSE, message=FALSE}
library(SmarterPoland)
head(auta2012, 2)
```

Które z tych zmiennych to zmienne jakościowe?

---

# Statystyki opisowe

Przyjrzyjmy się teraz takim cechom jak `Waluta` lub `Marka`. Cechy te są opisane przez wartości z określonej listy możliwości.
Dla cechy `Waluta` lista możliwości to `levels(auta2012$Waluta)`=`r levels(auta2012$Waluta)`.

Dla cech jakościowych możemy wykonać kilka operacji.
Jedną z nich jest wyświetlenie listy możliwych wartości. Taką listę nazywa się często słownikiem (spisem możliwych wartości).

Listę możliwych wartości dla zmiennej jakościowej można wyznaczyć funkcją `levels()`.

```{r, warning=FALSE}
levels(auta2012$Waluta)
```

Zmienne jakościowe często opisuje się tablicą liczebności, a więc informacją ile razy wystąpiła każda z wartości ze słownika.
Tablicę liczebności można wyznaczyć funkcją `table()` lub `summary()`. Jeżeli w zmiennej jakościowej występują wartości brakujące, to funkcja `summary()` też napisze ile ich jest.

```{r, warning=FALSE}
table(auta2012$Waluta)
summary(auta2012$Waluta)
```

---

# Zadania:

+ Ile zmiennych w zbiorze danych `auta2012` to zmienne jakościowe? 

+ Zmienna `Liczba.drzwi` przyjmuje wartości `2/3` i `4/5`. Zachowuje się ona jako zmienna jakościowa. Jednak można uznać, że liczba drzwi to cecha ilościowa, ponieważ opisuje _ilość_ drzwi w samochodzie. Jak wyjaśnić tę dualność?

Przykładowe odpowiedzi znajdują się na stronie https://rawgit.com/pbiecek/MOOC/master/0_dane/9_zadania.html

---

# Procenty

W pewnych sytuacjach, zamiast posługiwać się tablicą liczebności, wygodniej jest posługiwać się tabelą z procentami.

Ale jak te procenty policzyć?

Można to zrobić na kilka sposobów. Funkcja `prop.table()` dzieli wartości tabeli liczebności przez sumę liczebności, a więc zamienia liczebności na frakcje.
Przypiszmy wynik funkcji `table()` do jakiejś zmiennej, np. o nazwie `waluty` (nazwa może być dowolna, musimy jej jednak konsekwentnie używać w dalszych przykładach).
Następnie tak otrzymaną tabelę liczebności zamieniamy na frakcje.

W poniższym przykładzie, instrukcję przypisania wyniku obejmujemy napisami, po to by jej wynik był wyświetlony. Bez nawiasów wynik funkcji `table()` nie zostałby wyświetlony.

```{r, warning=FALSE}
(waluty <- table(auta2012$Waluta))
prop.table(waluty)
```

---

# Procenty

Funkcja `prop.table()` wyznacza frakcje, ale nie wyglądają one zbyt czytelnie dla człowieka. Wygodniej by było wypisać procenty. I to nie byle jakie procenty, ale procenty które są ładnie sformatowane, np. wyświetlone z dokładnością do jednego miejsca dziesiętnego po przecinku.

Aby zamienić frakcje na procenty, wystarczy je przemnożyć przez 100, a aby wynik przedstawić z dokładnością do jednego miejsca po przecinku wykorzystamy funkcję `round()`, która zaokrągla liczby do wskazanej liczby miejsc po kropce dziesiętnej.

```{r, warning=FALSE}
waluty <- table(auta2012$Waluta)
(frakcje <- prop.table(waluty))
(procenty <- 100*frakcje)
round(procenty, digits = 1)
```

 Wszystkie przedstawione powyżej operacje działają i na pojedynczych wartościach (nazywanych skalarami) jak i na wektorach. Przykładowo operacja `100*frakcje` wymnaża liczbę `100` z każdym elementem wektora `frakcje` i wynikiem tej operacji jest wektor. Nie w każdym języku programowania można mieć takie mieszane operacje mnożenia wektorów i skalarów.

---

# Procenty posortowane

Mamy już procenty. Aby dodatkowo zwiększyć czytelność tej formy prezentacji warto te procenty posortować rosnąco lub malejąco.

Nawet dla ośmiu liczb, jeżeli każda z nich jest opisana przez wiele cyfr, czasem w gąszczu cyfr trudno nawet dostrzec, która jest największa.

Do sortowania można wykorzystać funkcję `sort()`. Dodając argument `decreasing = TRUE` powodujemy, że wartości będą uporządkowane malejąco.

```{r, warning=FALSE}
zaokragloneProcenty <- round(procenty,1)
sort(zaokragloneProcenty)
sort(zaokragloneProcenty, decreasing = TRUE)
```

---

# Procenty posortowane

Wartości w wektorze można posortować też na kilka innych sposobów. 
Bardziej skomplikowanym, ale pozwalającym na omówienie bardziej zaawansowanych przykładów indeksowania jest funkcja `order()`.

Wynikiem funkcji `order()` są indeksy elementów w wektorze które tworzą ciąg rosnący. Więcej informacji o tej funkcji znaleźć można w odcinku 7.

```{r, warning=FALSE}
order(zaokragloneProcenty)
```

Jeżeli wektor `zaokragloneProcenty` będziemy czytać w kolejności, pierwszy element, trzeci, piąty, szósty, ósmy, czwarty, drugi i siódmy, to otrzymamy posortowany ciąg.

Możemy więc wynik tej funkcji wykorzystać do indeksowania oryginalnego zbioru danych, i w ten sposób posortować cały wektor.

```{r, warning=FALSE}
kolejnoscPosortowanych <- order(zaokragloneProcenty)
zaokragloneProcenty[kolejnoscPosortowanych]
```

A jak sprawdzić, na których pozycjach występują trzy najmniejsze wartości?

```{r, warning=FALSE}
kolejnoscPosortowanych[1:3]
```

---

# Zadania:

+ Cecha `Marka` opisuje markę samochodu. Sprawdź, która marka jest najpopularniejsza.

+ Cecha `Rodzaj.paliwa` opisuje rodzaj paliwa wykorzystywanego przez auto. Czy jest to benzyna, olej, gaz? Sprawdź jaki procent samochodów jest napędzana na benzynę.

Przykładowe odpowiedzi znajdują się na stronie https://rawgit.com/pbiecek/MOOC/master/0_dane/9_zadania.html

---

# Graficzne statystyki opisowe

Tabele liczebności są proste w interpretacji. Podobnie jednak jak w innych przypadkach, graficzne przedstawienie tych liczb pozwala na łatwiejsze dostrzeżenie zależności pomiędzy danymi. Koniec końców w tabeli liczb łatwo pomylić się nawet gdy chodzi o liczbę cyfr w liczbie. Na wykresie takie różnice natychmiast rzucają się w oczy.

Zazwyczaj tabele liczebności przedstawia się za pomocą wykresów słupkowych.
Wykresy słupkowe można wykonać np. funkcją `barplot()`.

```{r, warning=FALSE}
(tabela = table(auta2012$Waluta))
barplot(tabela)
```

Jeżeli chcemy, by słupki były przedstawiane poziomo, można dodać argument `horiz = TRUE`.

```{r, warning=FALSE, fig.height=8}
barplot(tabela, horiz = TRUE)
```

---

Domyślnie wartości są uporządkowane alfabetycznie. Nie zawsze jednak taka kolejność ma sens.
W tym przypadku rozsądniej jest posortować dane malejąco, co można wykonać z użyciem funkcji `sort()`.
Argument `las=1` powoduje, że oś OY ma etykiety ustawione poziomo.

```{r, warning=FALSE, fig.height=8}
(posortowanaTabela = sort(tabela))
barplot(posortowanaTabela, horiz = TRUE, las=1)
```

---

# Zadania:
+ Przedstaw graficznie tabelę liczebności dla zmiennej `Kraj.pochodzenia`. Wypróbuj wykres pionowy i poziomy. Aby obrócić kierunek etykiet na osiach dodaj do funkcji `barplot()` argument `las=1`.

# Odpowiedzi:
```{r, warning=FALSE, fig.height=8}
posortowanaTabela = sort(table(auta2012$Kraj.pochodzenia))
barplot(posortowanaTabela, horiz = TRUE, las=1)
```

Podobnie graficznie można przedstawiać cechy logiczne i napisowe.

---

# Napisy czy czynniki?

Z wyglądu cechy jakościowe (czynniki) przypominają cechy napisowe. 
Jednak pod spodem, ich reprezentacja jest zupełnie inna.
Czynniki nie są pamiętane jako napisy, ale jako para - wektor liczb i słownik, określający, który napis odpowiada, której liczbie.

Gdy dane są wczytywane z pliku w którym są napisy, dane te mogą być wczytane zarówno jako zmienne napisowe jak i jako czynnikowe. Domyślnie napisy są wczytywane jako czynniki, można to zobaczyć analizując wynik funkcji `str()`. 

W poniższym przykładzie, takie zmienne jak `gatunek` i `habitat` są wczytywane jako zmienna klasy `factor`. Efektem ubocznym jest sposób wyświetlania wyników np. przez zmienną `cat()`. Dla zmiennej czynnikowej, ta funkcja na ekranie wypisze liczby a nie wartości napisowe. 

```{r, warning=FALSE, fig.height=8}
koty_ptaki <- read.table("http://biecek.pl/MOOC/dane/koty.csv", 
          sep=";", dec=",", header=TRUE)
str(koty_ptaki)
cat(koty_ptaki$gatunek)
```

Funkcja `read.table()` ma argument `stringsAsFactors` określający w jaki sposób wczytywać kolumny z napisami. Ustawiwszy argument `stringsAsFactors=FALSE` wymuszamy wczytywanie danych jako zmienne napisowe. Zajmie to trochę więcej pamięci, ale samo wczytywanie będzie trochę szybsze.

Zauważmy jak teraz wygląda wynik funkcji `str()` i `cat()`.

```{r, warning=FALSE, fig.height=8}
koty_ptaki <- read.table("http://biecek.pl/MOOC/dane/koty.csv", 
          sep=";", dec=",", header=TRUE, stringsAsFactors=FALSE)
str(koty_ptaki)
cat(koty_ptaki$gatunek)
```

---

# Napisy czy czynniki?

Zmienne czynnikowe można konwertować na napisy funkcją `as.character()`.

Napisy można konwertować na zmienne czynnikowe funkcją `as.factor()`

```{r, warning=FALSE, fig.height=8}
czynniki <- as.factor(koty_ptaki$gatunek)
str(czynniki)
napisy <- as.character(czynniki)
str(napisy)
```

---

# Tablice częstości

Tablice częstości dla więcej niż jednej cechy wygodnie jest tworzyć funkcją `xtabs()`.
Pierwszym argumentem jest formuła o składni `~ zmienna_1 + .. + zmienna_n`, t.j. rozpoczynająca się tyldą a następnie ze zmiennymi porozdzielanymi znakiem plusa, drugim argumentem jest ramka danych, która powinna zawierać zmienne wymienione w formule. 

Wynikiem jest tablica kontyngencji o tylu wymiarach, ile zmiennych występuje w formule.

```{r, warning=FALSE, fig.height=8}
tabela <- xtabs(~Kraj.pochodzenia+Waluta, auta2012)
head(tabela)
```

---

# Tablice częstości

Tablice częstości nie są ramkami danych, choć gdy w grę wchodzi jedna lub dwie zmienne, to wyglądają jak ramki. Muszą być czymś innym, ponieważ muszą też obsługiwać sytuacje, gdy tablica kontyngencji dotyczy trzech lub większej liczby zmiennych a wynikowa macierz kontyngencji ma więcej wymiarów niż dwa. 

Gdy przekształci się wynik funkcji `xtabs()` do ramki danych, otrzyma się tak zwaną reprezentację rzadką macierzy kontyngencji, w której pierwsze kolumny opisują wszystkie kombinacje czynników zmiennych a ostania kolumna opisuje liczebność występowania poszczególnej kombinacji czynników.

```{r, warning=FALSE, fig.height=8}
xt <- xtabs(~Kraj.pochodzenia+Waluta, auta2012)
xt <- as.data.frame(xt)
head(xt)
```

---

# Kolejność czynników

Domyślna kolejność czynników, to kolejność leksykograficzna. 
Tworząc wykresy, zazwyczaj wartości prezentowane są zgodnie z kolejnością opisaną przez atrybut `levels`.

```{r, warning=FALSE, fig.height=8}
levels(auta2012$Rodzaj.paliwa)
boxplot(Rok.produkcji ~ Rodzaj.paliwa, auta2012, las=2)
```

Tę kolejność można jednak zmienić. 
Jednym ze sposobów określania kolejności czynników jest argument `levels` w funkcji `factor()`. Czynniki będą mieć kolejność zgodną z tam przedstawioną.

```{r, warning=FALSE, fig.height=8}
levels(auta2012$Skrzynia.biegow)
auta2012$Skrzynia.biegow <- factor(auta2012$Skrzynia.biegow, levels=c("manualna","", "automatyczna"))
```

Jeżeli chcemy ,,posortować'' poziomy zgodnie z pewną cechą ilościową, to wygodne będzie użycie funkcji `reorder()`. Jako argumenty pobiera ona wektor ze zmienną czynnikową, wektor z dowolną zmienną i funkcję. Dla każdej grupy określonej przez zmienną czynnikową, wartości wskazanych przez drugi argument, wyznaczana jest wartość funkcji - trzeciego argumentu. Następnie czynniki są porządkowane zgodnie z kolejnością wyników trzeciej funkcji.

W przykładzie poniżej, rodzaje paliwa są porządkowane zgodnie ze średnim rokiem produkcji aut o określonym rodzaju paliwa.

```{r, warning=FALSE, fig.height=8}
auta2012$Rodzaj.paliwa.posortowany <- reorder(auta2012$Rodzaj.paliwa, auta2012$Rok.produkcji, mean)

boxplot(Rok.produkcji ~ Rodzaj.paliwa.posortowany, auta2012, las=2)
```

---

# Nazwy czynników

Nazwy czynników można też zmieniać.
Najprościej można to zrobić używając funkcji `levels<-()`.

```{r, warning=FALSE, fig.height=8}
levels(auta2012$Rodzaj.paliwa)

levels(auta2012$Rodzaj.paliwa) <- c("", "B", "B+C", "B+L", "E", "H", "I", "L", "D", "W")
table(auta2012$Rodzaj.paliwa)
```

+ Mozaiki
