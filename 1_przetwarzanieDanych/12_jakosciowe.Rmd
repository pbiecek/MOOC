---
title: "Cechy jakościowe"
author: "pogRomcy danych"
date: "sezon 1 / odcinek 5 <br><br><br><br>Naciśnij `A` by zamienić slajdy na ciągły tekst. <br> Naciśnij `T` by wyświetlić spis treści."
output:
  slidy_presentation:
    includes:
      in_header: ../tracking.html
    highlight: default
    css: ../style.css
    font_adjustment: 0
    footer: "pogRomcy danych / przetwarzanie / zmienne jakościowe"

---

# O czym jest ten odcinek

W tym odcinku nauczymy się

- Jakie zmienne / wartości / cechy określa się terminem cechy jakościowe?
- Jakie podstawowe operacje można wykonywać na cechach jakościowe?
- Jak podsumowywać / opisywać cechy jakościowe?


Do ilustracji wykorzystamy dwa zbiory danych. Pierwszy, mały zbiór danych to `koty_ptaki` a drugi, znacznie większy to `auta2012`.


W trakcie tych zajęć przedstawimy podstawowe operacje na danych jakościowych. 
Ale zanim dojdziemy do tych operacji najpierw wczytajmy dane.

---

# Wczytanie danych

Każdy wiersz tego zbioru danych opisuje jedną ofertę sprzedaży auta. Każda kolumna opisuje jedną cechę / właściwość tej oferty.

```{r, warning=FALSE, message=FALSE}
library(SmarterPoland)
head(auta2012, 2)
```

---

# Cechy jakościowe
Przyjrzyjmy się teraz takim cechom jak `Waluta` lub `Marka`. Cechy te są opisane przez wartości z określonej listy możliwości.
Dla cechy `Waluta` lista możliwości to `r sort(levels(auta2012$Waluta))`.
Takie cechy określa się cechami jakościowymi w odróżnieniu od cech ilościowych.

## Statystyki opisowe
Dla cech jakościowych możemy wykonać kilka operacji.
Jedną z nich jest wyświetlenie listy możliwych wartości. Taką listę nazywa się często słownikiem (spisem możliwych wartości).

Listę możliwych wartości dla zmiennej jakościowej można wyznaczyć funkcją `levels()`.

```{r, warning=FALSE}
levels(auta2012$Waluta)
```

Zmienne jakościowe często opisuje się tablicą liczebności, a więc informacją ile razy wystąpiła każda z wartości ze słownika.
Tablicę liczebności można wyznaczyć funkcją `table()` lub `summary()`.

```{r, warning=FALSE}
table(auta2012$Waluta)
summary(auta2012$Waluta)
```

---

# Zadania:
+ Ile zmiennych w zbiorze danych `auta2012` to zmienne jakościowe? 
+ Zmienna `Liczba.drzwi` przyjmuje wartości `2/3` i `4/5`. Zachowuje się ona jako zmienna jakościowa. Jednak można uznać, że liczba drzwi to cecha ilościowa, ponieważ opisuje _ilość_ drzwi w samochodzie. Jak wyjaśnić tę dualność?

# Odpowiedzi:
+ `r names(which(sapply(auta2012, class) == "factor"))`
+ Pewne zmienne, w zależności od kontekstu, mogą być traktowane i analizowane jak zmienne ilościowe lub zmienne jakościowe. Do nas należy wybór, która z tych opcji jest właściwsza.

Przykładowo, w typowych analizach takich danych nie ma sensu liczenia sumy lub średniej liczby drzwi. Co by bowiem by znaczyło, że auta wystawione do sprzedaży w styczniu miały średnio 3.8 drzwi? Dla zwykłego odbiory taka średnia nie ma sensu, niewiele bowiem mówi o zmiennej.
Nie ma specjalnie sensu stwierdzenie, że samochody marki Porsche mają średnio o 0.5 mniej drzwi niż samochody marki Toyota.

Ale już, gdybyśmy byli warsztatem malarskim, który ma pomalować te wszystkie drzwi, i w cenniku ma cenę od elementu, dla takiego warsztatu suma drzwi może mieć sens. W takim przypadku sensownie byłoby potraktowanie tej zmiennej jako zmiennej ilościowej i zsumowanie liczby drzwi.

---

# Procenty

W pewnych sytuacjach, zamiast posługiwać się tablicą liczebności, wygodniej jest posługiwać się tabelą z procentami.
Ale jak te procenty policzyć?
Pokażemy to na przykładzie kilku funkcji. 

Funkcja `prop.table()` dzieli wartości tabeli liczebności przez sumę liczebności, a więc zamienia liczebności na frakcje.
Przypiszmy wynik funkcji `table()` do jakiejś zmiennej, np. o nazwie `tabela` (nazwa może być dowolna, musimy jej jednak konsekwentnie używać w dalszych przykładach).
Następnie tak otrzymaną tabelę liczebności zamieniamy na frakcje.

W poniższym przykładzie, instrukcję przypisania wyniku obejmujemy napisami, po to by jej wynik był wyświetlony. Bez nawiasów wynik funkcji `table()` nie zostałby wyświetlony.

```{r, warning=FALSE}
(tabela = table(auta2012$Waluta))
prop.table(tabela)
```

---

Zazwyczaj chcemy mieć wyznaczone procenty a nie frakcje. I to nie byle jakie procenty, ale procenty które są ładnie sformatowane, np. wyświetlone z dokładnością do jednego miejsca dziesiętnego po przecinku.
Aby zamienić frakcje na procenty, wystarczy je przemnożyć przez 100, a aby wynik przedstawić z dokładnością do jednego miejsca po przecinku wykorzystamy funkcję `round()`.

```{r, warning=FALSE}
(tabela = table(auta2012$Waluta))
(frakcje = prop.table(tabela))
procenty = 100*frakcje
round(procenty, digits = 1)
```

Zwróćmy przy okazji uwagę na pewien, często pomijany aspekt. Wszystkie przedstawione powyżej operacje działają i na pojedynczych wartościach (nazywanych skalarami) jak i na wektorach. Przykładowo operacja `100*frakcje` wymnaża liczbę `100` z każdym elementem wektora `frakcje` i wynikiem tej operacji jest wektor. Nie w każdym języku programowania można mieć takie mieszane operacje mnożenia wektorów i skalarów.

---

Ostatnim usprawnieniem tego procesu, które warto rozważyć to uporządkowanie wartości rosnąco lub malejąco.
Mając wiele możliwości, w gąszczu liczb czasem trudno nawet dostrzec, która jest największa. 
Posortowawszy te liczby łatwiej dostrzec najmniejsze i największe.
Do sortowania można wykorzystać funkcję `sort()`. Dodając argument `decreasing = TRUE` powodujemy, że wartości będą uporządkowane malejąco.

```{r, warning=FALSE}
zaokragloneProcenty = round(procenty,1)
sort(zaokragloneProcenty)
sort(zaokragloneProcenty, decreasing = TRUE)
```

Wartości można posortować też na kilka innych sposobów. 
Bardziej zaawansowanym, ale pozwalającym na omówienie bardziej zaawansowanych przykładów indeksowania jest funkcja `order()`.

Wynikiem funkcji `order()` są indeksy elementów w wektorze które tworzą ciąg rosnący. 

```{r, warning=FALSE}
order(zaokragloneProcenty)
```

Jeżeli wektor `zaokragloneProcenty` będziemy czytać w kolejności, pierwszy element, trzeci, piąty, szósty, ósmy, czwarty, drugi i siódmy, to otrzymamy posortowany ciąg.

Możemy więc wynik tej funkcji wykorzystać do indeksowania oryginalnego zbioru danych, i w ten sposób posortować cały wektor.

```{r, warning=FALSE}
kolejnoscPosortowanych <- order(zaokragloneProcenty)
zaokragloneProcenty[kolejnoscPosortowanych]
```

A jak sprawdzić, na których pozycjach występują trzy najmniejsze wartości?

```{r, warning=FALSE}
kolejnoscPosortowanych[1:3]
```

---

# Zadania:
+ Cecha `Marka` opisuje markę samochodu. Sprawdź, która marka jest najpopularniejsza.
+ Cecha `Rodzaj.paliwa` opisuje rodzaj paliwa wykorzystywanego przez auto. Czy jest to benzyna, olej, gaz? Sprawdź jaki procent samochodów jest napędzana na benzynę.

# Odpowiedzi:
+ `r names(which.max(table(auta2012$Marka)))`
+ `r 100*prop.table(table(auta2012$Rodzaj.paliwa))["benzyna"]` %

---

# Graficzne statystyki opisowe

Tabele liczebności są proste w interpretacji. Podobnie jednak jak w innych przypadkach, graficzne przedstawienie tych liczb pozwala na łatwiejsze dostrzeżenie zależności pomiędzy danymi. Koniec końców w tabeli liczb łatwo pomylić się nawet gdy chodzi o liczbę cyfr w liczbie. Na wykresie takie różnice natychmiast rzucają się w oczy.

Zazwyczaj tabele liczebności przedstawia się za pomocą wykresów słupkowych.
Wykresy słupkowe można wykonać np. funkcją `barplot()`.

```{r, warning=FALSE}
(tabela = table(auta2012$Waluta))
barplot(tabela)
```

Jeżeli chcemy, by słupki były przedstawiane poziomo, można dodać argument `horiz = TRUE`.

```{r, warning=FALSE, fig.height=8}
barplot(tabela, horiz = TRUE)
```

---

Domyślnie wartości są uporządkowane alfabetycznie. Nie zawsze jednak taka kolejność ma sens.
W tym przypadku rozsądniej jest posortować dane malejąco, co można wykonać z użyciem funkcji `sort()`.
Argument `las=1` powoduje, że oś OY ma etykiety ustawione poziomo.

```{r, warning=FALSE, fig.height=8}
(posortowanaTabela = sort(tabela))
barplot(posortowanaTabela, horiz = TRUE, las=1)
```

---

# Zadania:
+ Przedstaw graficznie tabelę liczebności dla zmiennej `Kraj.pochodzenia`. Wypróbuj wykres pionowy i poziomy. Aby obrócić kierunek etykiet na osiach dodaj do funkcji `barplot()` argument `las=1`.

# Odpowiedzi:
```{r, warning=FALSE, fig.height=8}
posortowanaTabela = sort(table(auta2012$Kraj.pochodzenia))
barplot(posortowanaTabela, horiz = TRUE, las=1)
```

Podobnie graficznie można przedstawiać cechy logiczne i napisowe.

---

# Napisy czy czynniki?

Z wyglądu cechy jakościowe (czynniki) przypominają cechy napisowe. 
Jednak pod spodem, ich reprezentacja jest zupełnie inna.
Czynniki nie są pamiętane jako napisy, ale jako para - wektor liczb i słownik, określający, który napis odpowiada, której liczbie.

Gdy dane są wczytywane z pliku w którym są napisy, dane te mogą być wczytane zarówno jako zmienne napisowe jak i jako czynnikowe. Domyślnie napisy są wczytywane jako czynniki, można to zobaczyć analizując wynik funkcji `str()`. 

W poniższym przykładzie, takie zmienne jak `gatunek` i `habitat` są wczytywane jako zmienna klasy `factor`. Efektem ubocznym jest sposób wyświetlania wyników np. przez zmienną `cat()`. Dla zmiennej czynnikowej, ta funkcja na ekranie wypisze liczby a nie wartości napisowe. 

```{r, warning=FALSE, fig.height=8}
koty_ptaki <- read.table("http://biecek.pl/MOOC/dane/koty.csv", 
          sep=";", dec=",", header=TRUE)
str(koty_ptaki)
cat(koty_ptaki$gatunek)
```

Funkcja `read.table()` ma argument `stringsAsFactors` określający w jaki sposób wczytywać kolumny z napisami. Ustawiwszy argument `stringsAsFactors=FALSE` wymuszamy wczytywanie danych jako zmienne napisowe. Zajmie to trochę więcej pamięci, ale samo wczytywanie będzie trochę szybsze.

Zauważmy jak teraz wygląda wynik funkcji `str()` i `cat()`.

```{r, warning=FALSE, fig.height=8}
koty_ptaki <- read.table("http://biecek.pl/MOOC/dane/koty.csv", 
          sep=";", dec=",", header=TRUE, stringsAsFactors=FALSE)
str(koty_ptaki)
cat(koty_ptaki$gatunek)
```

---

# Napisy czy czynniki?

Zmienne czynnikowe można konwertować na napisy funkcją `as.character()`.

Napisy można konwertować na zmienne czynnikowe funkcją `as.factor()`

```{r, warning=FALSE, fig.height=8}
czynniki <- as.factor(koty_ptaki$gatunek)
str(czynniki)
napisy <- as.character(czynniki)
str(napisy)
```

---

# Tablice częstości

Tablice częstości dla więcej niż jednej cechy wygodnie jest tworzyć funkcją `xtabs()`.
Pierwszym argumentem jest formuła o składni `~ zmienna_1 + .. + zmienna_n`, t.j. rozpoczynająca się tyldą a następnie ze zmiennymi porozdzielanymi znakiem plusa, drugim argumentem jest ramka danych, która powinna zawierać zmienne wymienione w formule. 

Wynikiem jest tablica kontyngencji o tylu wymiarach, ile zmiennych występuje w formule.

```{r, warning=FALSE, fig.height=8}
xtabs(~Kraj.pochodzenia+Waluta, auta2012) %>%
  head()
```

---

# Tablice częstości

Tablice częstości nie są ramkami danych, choć gdy w grę wchodzi jedna lub dwie zmienne, to wyglądają jak ramki. Muszą być czymś innym, ponieważ muszą też obsługiwać sytuacje, gdy tablica kontyngencji dotyczy trzech lub większej liczby zmiennych a wynikowa macierz kontyngencji ma więcej wymiarów niż dwa. 

Gdy przekształci się wynik funkcji `xtabs()` do ramki danych, otrzyma się tak zwaną reprezentację rzadką macierzy kontyngencji, w której pierwsze kolumny opisują wszystkie kombinacje czynników zmiennych a ostania kolumna opisuje liczebność występowania poszczególnej kombinacji czynników.

```{r, warning=FALSE, fig.height=8}
xt <- xtabs(~Kraj.pochodzenia+Waluta, auta2012)
as.data.frame(xt) %>%
  head()
```

---

# Kolejność czynników

Domyślna kolejność czynników, to kolejność leksykograficzna. 
Tworząc wykresy, zazwyczaj wartości prezentowane są zgodnie z kolejnością opisaną przez atrybut `levels`.

```{r, warning=FALSE, fig.height=8}
levels(auta2012$Rodzaj.paliwa)
boxplot(Rok.produkcji ~ Rodzaj.paliwa, auta2012, las=2)
```

Tę kolejność można jednak zmienić. 
Jednym ze sposobów określania kolejności czynników jest argument `levels` w funkcji `factor()`. Czynniki będą mieć kolejność zgodną z tam przedstawioną.

```{r, warning=FALSE, fig.height=8}
levels(auta2012$Skrzynia.biegow)
auta2012$Skrzynia.biegow <- factor(auta2012$Skrzynia.biegow, levels=c("manualna","", "automatyczna"))
```

Jeżeli chcemy ,,posortować'' poziomy zgodnie z pewną cechą ilościową, to wygodne będzie użycie funkcji `reorder()`. Jako argumenty pobiera ona wektor ze zmienną czynnikową, wektor z dowolną zmienną i funkcję. Dla każdej grupy określonej przez zmienną czynnikową, wartości wskazanych przez drugi argument, wyznaczana jest wartość funkcji - trzeciego argumentu. Następnie czynniki są porządkowane zgodnie z kolejnością wyników trzeciej funkcji.

W przykładzie poniżej, rodzaje paliwa są porządkowane zgodnie ze średnim rokiem produkcji aut o określonym rodzaju paliwa.

```{r, warning=FALSE, fig.height=8}
auta2012$Rodzaj.paliwa.posortowany <- reorder(auta2012$Rodzaj.paliwa, auta2012$Rok.produkcji, mean)

boxplot(Rok.produkcji ~ Rodzaj.paliwa.posortowany, auta2012, las=2)
```

---

# Nazwy czynników

Nazwy czynników można też zmieniać.
Najprościej można to zrobić używając funkcji `levels<-()`.

```{r, warning=FALSE, fig.height=8}
levels(auta2012$Rodzaj.paliwa)

levels(auta2012$Rodzaj.paliwa) <- c("", "B", "B+C", "B+L", "E", "H", "I", "L", "D", "W")
table(auta2012$Rodzaj.paliwa)
```


