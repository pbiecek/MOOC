---
title: "Functions"
author: "Data CruncheRs"
date: season 1 / episode 10<br><br><br><br>Press `A` to change slides into text <br> Press `T` to display table of contents.
output:
  slidy_presentation:
    css: ../style.css
    font_adjustment: 0
    footer: Data CruncheRs / programming / functions
    highlight: default
    includes:
      in_header: ../tracking.html
---

# What is this episode about?

One of the most crucial features of programming languages is the fact that they allow us to use ready-made solutions created in the past by ourselves or by some other users. It is possible, however, only if we transform our good solutions into functions, that is, chunks of code, which can be easily reused.

In this episode you will learn:

- How to call functions?
- How to create your own functions?
- How to call functions out of functions?

As an illustration I will use the data set `koty_ptaki` available in the package `PogromcyDanych`. 



```{r, message=FALSE, warning=FALSE}
library(PogromcyDanych)
head(koty_ptaki, 3)
```

---

#Functions

There are many reasons for using functions. These are the three most important ones:

* Functions allow us to easily reuse the fragments of code which have already been created. We can use the solutions which we have designed in the past and thus create new ones much faster. We can also use the solutions/functions of other users and share our own functions with them. 

* Functions create a logical division of the program; its elements become easier to grasp and document. We can much more easily understand  how the program works because we get to know its elements separately. 

* Functions shorten the program. They allow us to substitute similar chunks of code with functions and thus reduce the number of similar chunks. The shorter the program, the easier it is to write it, understand it and detect potential mistakes in it. 


---

# Functions

Let us recall the code of the program from the episode 8 which drew speed of species of animals as a specific number of dots. 

If we wanted to use the same manner of data presentation again, we would have to write the same code anew. You will learn in this episode how to transform a useful fragment of the code into one or more functions so that you could use it easily afterwards. 

```{r, message=FALSE, warning=FALSE}
# for the purpose of printing, we transform the variable into character type
koty_ptaki$gatunek <- as.character(koty_ptaki$gatunek)

# For each row in the `koty_ptaki` data frame, we represent the speed with the number of dots
for (i in 1:nrow(koty_ptaki)) {
  n_dots <- koty_ptaki[i,"predkosc"] / 5
  for (j in 1:n_dots) {
    cat(".")
  }
  cat(" ", koty_ptaki[i,"gatunek"], "\n")
}
```

---

# Functions

We use the word `function` to create functions. For each function we need to specify a list of its arguments and the so-called function body, which is a list of commands that a given function performs.

```{r, message=FALSE, warning=FALSE, eval=FALSE}
function(comma_separated_arguments) {
  expression
}
```

where `comma_separated_arguments` is a list of arguments separated by commas (which can have one or no arguments at all as well), and `expression` are commands which are to be carried out when the function is called. 

The result of the command presented above is a function which needs to be attributed to a variable so that it could be used in the future. This is why the most common declarations include attribution to function, as you can see in the declaration below. 

```{r, message=FALSE, warning=FALSE, eval=FALSE}
function_name <- function(comma_separated_arguments) {
  expression
}
```

It is also good to remember that a function does not necessarily need a name. You will see later on that we will often use anonymous, that is, unnamed functions.

---

# Functions with arguments

Now we will create a function with dots as an example and we will attribute it to the variable `draw_dots`. This function will take only one argument `n_dots` and it will draw exactly as many dots as we specify.

We will use the loop `for` to draw the dots. 

```{r, message=FALSE, warning=FALSE}
draw_dots <- function(n_dots) {
  # using the loop for we draw n_dots dots
  for (j in 1:n_dots) {
    cat(".")
  }
}
```

In the example below a function drawing 20 dots is called.

```{r, message=FALSE, warning=FALSE}
draw_dots(n_dots = 20)
```
 

If we write the arguments in the default order, we do not need to specify their names. This rule applies to both our own and *original* functions.

In the example below we give the value of the argument. As the name of the argument is not specified, the value will be attributed to the first (in this case the only one) argument. 

```{r, message=FALSE, warning=FALSE}
draw_dots(20)
```

---

# Functions: default arguments

If we frequently call a function selecting the same value of a parameter, we can easily spare ourselves a lot of writing by defining that value as a default value.

When we declare a function, we write the default value after the sign `=`. The example below creates a new function (overwriting the previous declaration at the same time) with the default value of the parameter `n_dots`. 

```{r, message=FALSE, warning=FALSE}
draw_dots<- function(n_dots = 20) {
  for (j in 1:n_dots) {
    cat(".")
  }
}
```

When the default values are specified and we do not write the value of the argument, the function will automatically select the default value. This option is very convenient when our function has got many arguments. 

```{r, message=FALSE, warning=FALSE}
draw_dots() 
```

However, when we specify value of the argument, it will overwrite the default declaration. 

```{r, message=FALSE, warning=FALSE}
draw_dots(35) 
```

---

# Functions: dealing with various scenarios

We would like our functions to work just as we have planed.  However, in reality functions are sometimes faulty. We also have to face unexpected situations from time to time.

For example, when we call the function `draw_dots()` with the argument `0` we would expect 0 dots, but...

```{r, message=FALSE, warning=FALSE}
draw_dots(0) 
```

Why is that so?

.

It is so because the vector `1:0` in the loop 1:n_dots which is located in the declaration of the function in fact contains two elements. 


```{r, message=FALSE, warning=FALSE}
1:0
```

So, if we want our function to work properly for `n_dots = 0`, we need to deal with this situation differently.

How to solve this problem?

---

# Functions: dealing with various scenarios

We can deal with this problem in several ways. We will employ a solution using the command `if()`. 

We check whether `n_dots` is equal to/less than 0 (if yes, do not draw anything) or more than 0 (if yes, draw the dots). 

```{r, message=FALSE, warning=FALSE}
draw_dots <- function(n_dots = 20) {
  # is the number of dots we want to print greater than zero?
  if (n_dots > 0) {
    for (j in 1:n_dots) {
      cat(".")
    }
  } 
}
```

It works well for the argument 0.
```{r, message=FALSE, warning=FALSE}
draw_dots(0)
```

It works well for the default arguments.
```{r, message=FALSE, warning=FALSE}
draw_dots()
```

It works well for other values.
```{r, message=FALSE, warning=FALSE}
draw_dots(30)
```

---

# Functions: more arguments

Functions may have more arguments and each of the arguments can have (or not) a default value.

If we give arguments in the order different than the defaut order while calling a function, we have to also specify which arguments we are determining.

As an illustration let us now add an argument describing a sign to be drawn by the function. 

```{r, message=FALSE, warning=FALSE}
draw_dots <- function(n_dots = 20, signs = ".") {
  if (n_dots > 0) {
    for (j in 1:n_dots) {
      cat(signs)
    }
  }
}
```

And a series of calls. We specify now the second argument while the first one assumes its default value. We must remember to specify the name of the argument. 

```{r, message=FALSE, warning=FALSE}
draw_dots(signs="X")
```


```{r, message=FALSE, warning=FALSE}
draw_dots(35)
```

We can give arguments in any order provided that we give them along with their names. 

```{r, message=FALSE, warning=FALSE}
draw_dots(signs="X", n_dots = 30)
```

---

# Functions - a function within a function

When we create new functions we can also use other already defined functions.

As an example I will draw a function which draws a dot chart for a vector of characters and a vector of values. 


```{r, message=FALSE, warning=FALSE}
draw_dotplot<- function(name, values) {
  # we assume that both vectors are of the same length
  # function seq_along(name) creates a sequence from 1 to the length of vector name
  for (i in seq_along(name)) {
    draw_dots(values[i])
    cat(" ", name[i],"\n")
  }
}
```

And an exemplary call. 
```{r, message=FALSE, warning=FALSE}
draw_dotplot(koty_ptaki$gatunek, koty_ptaki$predkosc/5)
```

It is best when our functions are not too long. We can easily describe them and memorize the range of their operations if they are relatively short. For the same reason it is also good to give the functions names and to document them. 

---

# Functions reporting errors

The assumption of the function from the previous slide was that both vectors are of the same length.

However, what if they are not? Maybe the user does not even know that they should be?


We should check such assumptions e.g. with the command `if()`. If the assumption is valid and the function cannot be performed if the assumption is not satisfied, we can stop the function and identify the error with the command `stop()`. 

```{r, message=FALSE, warning=FALSE}
draw_dotplot <- function(name, values) {
  # are both arguments of the same length?
  if (length(name) != length(values)) {
    # function stop() stops our function
    stop("Arguments of different lenghts! ", length(name), " and ", length(values))
  }
  # if both condition are satisfied, we may proceed with the execution of the rest of the function
  for (i in seq_along(name)) {
    draw_dots(values[i])
    cat(" ", name[i],"\n")
  }
}
```

What will happen if we call the function with wrong arguments?

```{r, message=FALSE, warning=FALSE, eval=FALSE}
draw_dotplot(koty_ptaki$gatunek, 5)
```


---

# Passing the arguments along 

List of function's arguments contains also a special argument `...` . It allows us to pass along all the other arguments to the internal functions.

In the example below the operator `...` can be seen in two places - in the list of arguments of the function `draw_dotplot()` and in the list of arguments of the function `draw_dots()`. 

All the arguments of the function `draw_dotplot()` which have names different from `name` and `values`  will be passed along to the function `draw_dots()`. 

```{r, message=FALSE, warning=FALSE}
draw_dotplot <- function(name, values, ...) {
  for (i in seq_along(name)) {
    draw_dots(values[i], ...)
    cat(" ", name[i],"\n")
  }
}
```

Let us illustrate this case with an example. We call `draw_dotplot()` with three arguments. The third argument, `signs = "x"` will be passed along to the function `draw_dots()` and as result there will be the x signs on the chart. 

```{r, message=FALSE, warning=FALSE}
draw_dotplot(name = LETTERS[1:5], values = 1:5, signs = "X")
```


---

# Functions returning values

The name functions refers to the fact that they return their values.

But the functions which we have created previously displayed their results on the screen. 

The default result of a function is the result of the last expression in the function. Another way to achieve a result is to use the function `return()` which stops the function and return the value of the function `return()` as a result. 

Look at the following example. The  function `suma_liczb_losowych()` draws `n` numbers and returns their sum as a result. 

However, if the argument is a value smaller than 1, the function is stopped and we get the value 0 as a  result.

```{r, message=FALSE, warning=FALSE}
sum_of_n_random <- function(n = 10) {
  if (n < 1) {
    return(0)
  } 
  sum(runif(n))
}
```

Let us call that function. If its results is not attributed to any variable, it will be displayed on the screen. 

```{r, message=FALSE, warning=FALSE}
sum_of_n_random(10) 
```

And the result when the argument is less than 1. 

```{r, message=FALSE, warning=FALSE}
sum_of_n_random(-1) 
```

---

# Summary of R commands

In this episode we have discusses the functions with and without arguments and the functions with and without results. 

Below you can see a list of all the commands used in this episode. 


```{r, eval=FALSE}
# Creating a functions that prints n_dots of dots
draw_dots<- function(n_dots) {
  for (j in 1:n_dots) {
    cat(".")
  }
}

# Function can be called with or without arguments names
draw_dots(n_dots = 20)
draw_dots(20)

# Creating a function with the default value of argument n_dots
draw_dots <- function(n_dots = 20) {
  for (j in 1:n_dots) {
    cat(".")
  }
}

# Thanks to the if() instruction, our function now works properly with arguments smaller than 1
draw_dots <- function(n_dots = 20) {
  if (n_dots > 0) {
    for (j in 1:n_dots) {
      cat(".")
    }
  } 
}
```

---

# Summary of R commands

Below you can see a list of all the commands used in this episode. 


```{r, eval=FALSE}
# Adding another argument, determining what signs are to be printed. By default, they are dots
draw_dots <- function(n_dots = 20, signs = ".") {
  if (n_dots > 0) {
    for (j in 1:n_dots) {
      cat(signs)
    }
  }
}

# We can pass arguments in any order, providing that they came along with they names
draw_dots(signs="X", n_dots = 30)

# We call a function from inside of another function
draw_dotplot<- function(name, values) {
  for (i in seq_along(name)) {
    draw_dots(values[i])
    cat(" ", name[i],"\n")
  }
}

# In the case arguments are incorrect, we stop the execution with stop()
draw_dotplot <- function(name, values) {
  # are both arguments of the same length?
  if (length(name) != length(values)) {
    stop("Arguments of different lenghts! ", length(name), " and ", length(values))
  }
  for (i in seq_along(name)) {
    draw_dots(values[i])
    cat(" ", name[i],"\n")
  }
}
```

---

# Summary of R commands

Below you can see a list of all the commands used in this episode. 


```{r, eval=FALSE}
# You may pass the arguments along using ...
draw_dotplot <- function(name, values, ...) {
  for (i in seq_along(name)) {
    draw_dots(values[i], ...)
    cat(" ", name[i],"\n")
  }
}

#  In this example, the last argument is passed
draw_dotplot(name = LETTERS[1:5], values = 1:5, signs = "X")

# Function which returns the number
sum_of_n_random <- function(n = 10) {
  if (n < 1) {
    return(0)
  } 
  sum(runif(n))
}

 Two sample calls, which returns the result with different methods
# Using last computed value
sum_of_n_random(10) 
# using the function return()
sum_of_n_random(-1) 
```

---


# Exercises

* Write a function which receives a numerical argument and then displays  the values from the argument to one on the screen. 

* Write a function  which receives a numerical argument `n` and then draws a square with a side `n` full of `x` signs.

* Write a function which assumes numerical argument `n` and then draws a square with a side `n` with `x` sign around its sides but not in the middle.


You can find sample answers at https://rawgit.com/pbiecek/MOOC/master/0_dane/9_zadania.html

