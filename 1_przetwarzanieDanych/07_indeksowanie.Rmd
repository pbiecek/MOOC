---
title: "Indeksowanie ramek danych i wektorów"
author: "pogRomcy danych"
date: "sezon 1 / odcinek 7<br><br> Wszelkie prawa zastrzeżone.<br> Wykorzystanie możliwe wyłącznie za zgodą autora.  <br><br><br><br>Naciśnij `A` by zamienić slajdy na ciągły tekst. <br> Naciśnij `T` by wyświetlić spis treści."
output:
  slidy_presentation:
    includes:
      in_header: ../tracking.html
    highlight: default
    css: ../style.css
    font_adjustment: 0
    footer: "pogRomcy danych / eksploracja danych / indeksowanie"
---

# O czym jest ten odcinek

Dane z którymi będziemy pracować mają najczęściej format tabeli lub wektora. 
Jedną z podstawowych operacji na tabelach oraz wektorach jest wybieranie podzbioru wierszy, kolumn lub wartości.

W tym odcinku dowiemy się

- Jak tworzyć wektory
- Jak indeksować wartości z wektora
- Jak wybierać wiersze z ramki danych
- Jak wybierać kolumny z ramki danych
- Jak wybierać wiersze i kolumny
- Jak indeksować wiersze i kolumny używając nazw lub wartości logicznych

---

# Wektory

Jednym z podstawowych rodzajów danych w programie R są wektory. 

Wektory mogą zawierać liczby, napisy, wartości logiczne lub inne typy. Zacznijmy od wektorów wartości liczbowych.

W programie R nawet jedna wartość jest wektorem, tyle że małym, jednoelementowym.

```{r}
4
```

Dłuższe wektory można tworzyć np. funkcją `c()`, która pozwala na sklejenie kilku wartości w jeden wektor. 

Przykładowa instrukcja tworząca wektor o trzech elementach.

```{r}
c(3, 4, 5)
```

W programowaniu i analizie danych bardzo często wykorzystuje się wektory kolejnych wartości liczbowych. Takie wektory mają nawet specjalną nazwę *sekwencje*.

Sekwencje kolejnych liczb można stworzyć operatorem `:`. Jeżeli chcemy zbudować sekwencję liczb równie odległych od siebie, ale z krokiem innym niż 1, to wygodnie jest wykorzystać funkcję `seq()`.

```{r}
2:7
seq(from = 3, to = 15, by = 2)
```

---

# Wektory

Używając funkcji `c()` można tworzyć wektory wartości logicznych (z dwoma możliwymi stanami PRAWDA/FAŁSZ oznaczanymi `TRUE`/`FALSE`), wektory napisów oraz innego rodzaju wartości.

Aby wykorzystać wektor później, trzeba go przypisać do zmiennej. Można to zrobić używając operatora `->` lub `=`.
Jeżeli chcemy wyświetlić zawartość zmiennej to wystarczy wpisać ją do konsoli i nacisnąć ENTER.

```{r, message=FALSE, warning=FALSE}
co_drugi <- c(TRUE, FALSE, TRUE, FALSE, TRUE, FALSE)
co_drugi

literki <- c("alfa", "beta", "gamma", "delta")
literki
```

W dalszym ciągu tego odcinka wykorzystamy wektor kolejnych liter w języku angielskim zapisany w zmiennej `LETTERS`. Użyjemy tego wektora do ćwiczeń w indeksowaniu.

```{r, message=FALSE, warning=FALSE}
LETTERS
```

---

# Indeksowanie wektora

Indeksowanie oznacza wybieranie określonych wartości. Wartości wybieramy wskazując ich indeksy. Brzmi jak masło maślane? 

Wektor to ciąg elementów. Pierwszy z tych elementów ma indeks 1, kolejny 2, kolejny 3 i tak aż do ostatniego elementu. Indeks ostatniego elementu to jednocześnie długość wektora. Można ją sprawdzić funkcją `length()`.

```{r, message=FALSE, warning=FALSE}
length(LETTERS)
```

Aby odwołać się do określonych indeksów wektora należy użyć operatora `[]`. Wewnątrz nawiasów kwadratowych podaje się indeks elementu, do którego chcemy się odwołać.

```{r, message=FALSE, warning=FALSE}
# pierwszy element wektora
LETTERS[1]
# piąty
LETTERS[5]
# ostatni element wektora
LETTERS[26]
# zamiast podawać wartość 26 można wstawić funkcję, która jako wynik zwróci długość wektora
LETTERS[length(LETTERS)]
```

---

# Indeksowanie wektora

Odwołując się do wektorów, możemy podać indeks więcej niż jednej wartości. Zasada jest jednak taka, że indeksy muszą być wektorem. Do tego przyda nam się już poznana funkcja `c()`.

Przykładowo, aby wybrać pierwszy, piąty i ostatni element z wektora LETTERS musimy wpierw skonstruować wektor z tymi trzema indeksami.

```{r, message=FALSE, warning=FALSE}
LETTERS[c(1,5,26)]
```

Równoważnie można najpierw stworzyć wektor indeksów a następnie wykorzystać go do indeksowania wektora `LETTERS`.

```{r, message=FALSE, warning=FALSE}
indeksy <- c(1, 5, 26)
LETTERS[indeksy]
```

Aby wybrać więcej elementów z wektora wygodnie jest wykorzystać sekwencje.

```{r, message=FALSE, warning=FALSE}
# dziesięć pierwszych liter
LETTERS[1:10]
# pięć pierwszych i pięć ostatnich
LETTERS[c(1:5, 21:26)]
# co druga litera, indeksujemy sekwencją od 1 do 26 z krokiem co 2
coDruga <- LETTERS[seq(from = 1, to = 26, by = 2)]
coDruga
```

---

# Indeksowanie wektora

Sekwencje wartości nie muszą być rosnące. Można je wykorzystać np. do tego by odwrócić kolejność elementów w wektorze.

```{r, message=FALSE, warning=FALSE}
10:1
LETTERS[10:1]
```

Elementy wektora można również indeksować warunkiem logicznym. 

W poniższym przykładzie instrukcja `LETTERS > "K"` tworzy wektor wartości logicznych weryfikujących czy kolejna litera jest większa czy mniejsza od `K` (w porządku leksykograficznym),

Taki wektor wartości logicznych można wykorzystać do indeksowania wektora `LETTERS`.

```{r, message=FALSE, warning=FALSE}
LETTERS > "K"
# tylko litery spełniające określony warunek
# w tym przypadku litery występujące po literze 'K'
LETTERS[LETTERS > "K"]
```

---

# Zadania

- Zbuduj sekwencję dziesięciu kolejnych małych liter alfabetu łacińskiego.

- Zbuduj sekwencję dziesięciu kolejnych liczb nieparzystych zaczynając od 3.

- Z wektora `LETTERS` wybierz litery na pozycjach 5, 10, 15, 20 i 25.

- Wypisz wartości wektora `LETTERS` od końca.

---

# Ptaki vs koty

Do pracy nad wybieraniem wierszy i kolumn wykorzystamy niewielki zbiór danych o kotach i ptakach.

Ten zbiór danych jest dostępny w pakiecie `SmarterPoland`, wystarczy więc załadować ten pakiet. Inne sposoby na wczytanie tego zbioru danych były przedstawione w odcinku 5. 

Siedem kolumn i trzynaście wierszy to dobry zbiór do ćwiczeń.

```{r, message=FALSE, warning=FALSE}
library(SmarterPoland)
koty_ptaki
```

---

# Indeksowanie wierszy w ramce danych

Zasadnicza różnica pomiędzy wektorem a ramką danych jest taka, że wektor jest jednowymiarowy. Wartości są ustawione w ciągu. W ramce danych wartości są ułożone w dwa wymiary, wiersze i kolumny. Indeksując wartości w ramce danych podaje się wektor indeksów dla wierszy i wektor wartości dla kolumn.

Aby odwoływać się do wierszy lub kolumn ramki danych można wykorzystać operator `[,]`. Obowiązkowym elementem jest przecinek. Przed przecinkiem należy wpisać indeksy wierszy, po przecinku indeksy kolumn. Jeżeli przed przecinkiem lub po przecinki nie będzie żadnych wartości to wybrane będą wszystkie elementy w wierszu / kolumnie.

Przykładowo, odwołanie się do trzeciego wiersza z ramki danych

```{r, message=FALSE, warning=FALSE}
koty_ptaki[3, ]
```

Liczbę wierszy można sprawdzić funkcją `nrow()`, przydatne, jeżeli np. chcemy wyświetlić ostatni wiersz.

```{r, message=FALSE, warning=FALSE}
nrow(koty_ptaki)
koty_ptaki[13, ]
```

---

# Indeksowanie wierszy w ramce danych

Jeżeli chcemy wybrać więcej niż jeden wiersz należy, podobnie jak dla wektorów, podać kilka indeksów przed przecinkiem.

Aby odwołać się do kilku kolejnych wierszy można wykorzystać sekwencję zbudowaną z operatorem `:`.

Przykładowo, wiersze od 8 do 10 z ramki danych `koty_ptaki` można wyłuskać następująco.

```{r, message=FALSE, warning=FALSE}
koty_ptaki[8:10, ]
```

Funkcja `c()` skleja wartości i sekwencje  wektor, który można następnie wykorzystać w indeksowaniu wierszy.

Poniższa instrukcja wyłuskuje wiersze 3, 8, 9 i 10.

```{r, message=FALSE, warning=FALSE}
koty_ptaki[c(3, 8:10), ]
```

Lub równoważnie

```{r, message=FALSE, warning=FALSE}
indeksy <- c(3, 8:10)
koty_ptaki[indeksy, ]
```

Funkcjami `head()` i `tail()` wyłuskuje się pierwsze lub ostatnie 6 wierszy ze zbioru danych. Do obu funkcji można podać drugi argument, określający ile pierwszych / ostatnich wierszy chcemy odczytać, domyślnie jest to 6 wierszy.

```{r, message=FALSE, warning=FALSE}
head(koty_ptaki)
tail(koty_ptaki)
```

---

# Indeksowanie wierszy w ramce danych

Jako indeksy można również wykorzystać wektor wartości logicznych. 

Wybiegając trochę w przyszłość, użyjemy kolumny `predkosc` aby wybrać z ramki danych tylko te wiersze, dla których 
prędkość jest wyższa niż 100.

```{r, message=FALSE, warning=FALSE}
najszybsze <- koty_ptaki$predkosc > 100
najszybsze

koty_ptaki[najszybsze, ]
```

---

# Indeksowanie wierszy w ramce danych

Indeksując wiersze lub kolumny można też wykorzystywać ujemne indeksy. Oznaczają one, wszystkie wartości poza wskazanymi.

Przykładowo, wszystkie wiersze poza 1, 3, 8, 9 i 10 można uzyskać poleceniem.

```{r, message=FALSE, warning=FALSE}
koty_ptaki[ - c(1, 3, 8:10), ]
```

Nie można mieszać jednocześnie wartości dodatnich i ujemnych.

---

# Indeksowanie kolumn w ramce danych

Podobnie jak wiersze, można indeksować również kolumny. 

Aby wyłuskać drugą kolumnę można wskazać jej numer po przecinku.

```{r, message=FALSE, warning=FALSE}
koty_ptaki[, 2]
```

Wybranie jednej kolumny powoduje, że jako wynik otrzymujemy nie ramkę danych ale wektor.
Łatwo to poznać po sposobie wyświetlania danych.

Aby zapobiec takiej konwersji na wektor i jako wynik wciąż mieć ramkę danych, należy dodać do operatora indeksowania argument `drop=FALSE`. 

```{r, message=FALSE, warning=FALSE}
koty_ptaki[,2, drop=FALSE]
```

*Uwaga* Ten dziwny zapis jest konsekwencją tego, że operator `[,]` jest w gruncie rzeczy funkcją. Więcej o zaawansowanych elementach języka dowiemy się w kolejnych odcinkach.

---

# Indeksowanie kolumn w ramce danych

W ramce danych kolumny możemy indeksować nie tylko numerami ale również nazwami (kolumny są nazywane).

Nazwy kolumn z ramki danych można odczytać funkcją `colnames()`. Wynikiem tej funkcji jest wektor z nazwami.

```{r, message=FALSE, warning=FALSE}
colnames(koty_ptaki)
```

Aby wyłuskać z ramki danych kolumnę o nazwie `waga` możemy użyć tej nazwy jako indeksu.

```{r, message=FALSE, warning=FALSE}
koty_ptaki[, "waga"]
```

Ponieważ operacja odwołania się do jednej kolumny w danych jest dosyć częsta, można ją wykonać na kilka innych sposobów. Najpopularniejszym jest użycie operatora `$`. 

Z jego pomocą do kolumny `waga` możemy odwołać się w ten sposób.

```{r, message=FALSE, warning=FALSE}
koty_ptaki$waga
```

---

# Indeksowanie kolumn w ramce danych

Aby wybrać więcej niż jedna kolumnę, podobnie jak w przypadku wierszy i wektorów można wykorzystać funkcję `c()`.

Przykładowo, jeżeli chcemy wybrać drugą, czwartą, piątą i szóstą kolumnę możemy użyć instrukcji.

```{r, message=FALSE, warning=FALSE}
# równoważnie moglibyśmy napisać 
# koty_ptaki[, c("waga", "predkosc", "habitat", "zywotnosc")]
koty_ptaki[, c(2,4:6)]
```

---

# Wybieranie podramki z ramki danych

Możemy jednocześnie odwoływać się do wierszy i kolumn w ramce danych, wybierając jej podramkę.

Przykładowo, wybór czterech wierszy i czterech kolumn może wyglądać tak.

```{r, message=FALSE, warning=FALSE}
koty_ptaki[c(3,8:10), c(2,4:6)]
```

Wybór czterech wierszy i jednej kolumny.

```{r, message=FALSE, warning=FALSE}
koty_ptaki[c(3,8:10), 2]
```

Jeden wiersz i cztery kolumny.

```{r, message=FALSE, warning=FALSE}
koty_ptaki[3, c(2,4:6)]
```

---

# Wybieranie podramki z ramki danych nazwami

Pokazaliśmy wcześniej, jak można odwoływać się do kolumn poprzez ich nazwy. 

Podobnie można zrobić z wierszami. Funkcja `rownames()` pokazuje jak nazywają się wiersze w ramce danych.

```{r, message=FALSE, warning=FALSE}
rownames(koty_ptaki)
```

Te nazwy niewiele mówią, używanie ich do indeksowania nie miałoby sensu. Zmieńmy więc nazwy wierszy na takie jak w kolumnie `gatunek`

```{r, message=FALSE, warning=FALSE}
rownames(koty_ptaki) <- koty_ptaki$gatunek
```

Teraz możemy odwoływać się do wierszy poprzez nazwy tych wierszy.

Poniższy przykład wybiera wiersze dla czterech wskazanych gatunków oraz trzy wybrane kolumny. Jeżeli wiersze mają sensowne, to bardzo ułatwiają odwoływanie się do wierszy.

```{r, message=FALSE, warning=FALSE}
koty_ptaki[c("Lew", "Leopard", "Jerzyk", "Strus"),
           c("waga", "dlugosc", "predkosc")]
```

*Uwaga* Gdybyśmy chcieli pozbyć się nazw wierszy, można to zrobić instrukcją
```{r, eval=FALSE}
rownames(koty_ptaki) <- NULL
```

---

# Podsumowanie instrukcji R

W tym odcinku omawialiśmy funkcje służące do tworzenia wektorów, sekwencji oraz indeksowania wektorów.

```{r, eval=FALSE}
# tworzenie wektorów liczb i sekwencji
c(3, 4, 5)
2:7
seq(from = 3, to = 15, by = 2)

# wektory wartości logicznych i napisowych
co_drugi <- c(TRUE, FALSE, TRUE, FALSE, TRUE, FALSE)
co_drugi

literki <- c("alfa", "beta", "gamma", "delta")
literki

# wyznaczanie długości wektora LETTERS
length(LETTERS)

# indeksowanie pojedynczego elementu wektora, pierwszy element
LETTERS[1]
# zamiast podawać wartość 26 można wstawić funkcję, która jako wynik zwróci długość wektora
LETTERS[length(LETTERS)]

# indeksowanie kilku elementów wektora
LETTERS[c(1,5,26)]
# z użyciem zmiennej pomocniczej
indeksy <- c(1, 5, 26)
LETTERS[indeksy]

# dziesięć pierwszych liter od J do A
LETTERS[10:1]
# pięć pierwszych i pięć ostatnich
LETTERS[c(1:5, 21:26)]
# co druga litera, indeksujemy sekwencją od 1 do 26 z krokiem co 2
LETTERS[seq(from = 1, to = 26, by = 2)]

# używanie wartości logicznych do indeksowania wektora tylko litery występujące po literze 'K'
LETTERS[LETTERS > "K"]
```

---

# Podsumowanie instrukcji R

W tym odcinku omawialiśmy funkcje służące do indeksowania wierszy w ramkach danych.

```{r, eval=FALSE}

# indeksowanie pojedynczego wiersza
koty_ptaki[3, ]

# liczba wierszy
nrow(koty_ptaki)

# indeksowanie kilku wierszy 
koty_ptaki[8:10, ]
koty_ptaki[c(3, 8:10), ]
# z użyciem zmiennej pomocniczej
indeksy <- c(3, 8:10)
koty_ptaki[indeksy, ]

# pierwsze 6 wierszy i ostatnie 6 wierszy
head(koty_ptaki)
tail(koty_ptaki)

# indeksowanie wierszy warunkiem logicznym
najszybsze <- koty_ptaki$predkosc > 100
koty_ptaki[najszybsze, ]

# używanie ujemnych indeksów by pominąć wiersze
koty_ptaki[ -c(1, 3, 8:10), ]
```

---

# Podsumowanie instrukcji R

W tym odcinku omawialiśmy funkcje służące do indeksowania kolumn oraz jednocześnie wierszy i kolumn.

```{r, eval=FALSE}
# indeksowanie kolumn, tylko druga kolumna, wynikiem jest wektor
koty_ptaki[, 2]
# drop=FALSE powoduje, że wynikiem jest ramka danych
koty_ptaki[,2, drop=FALSE]

# nazwy kolumn
colnames(koty_ptaki)

# indeksowanie jednej kolumny z użyciem nazwy
koty_ptaki[, "waga"]
koty_ptaki$waga

# indeksowanie kilku kolumn 
# koty_ptaki[, c("waga", "predkosc", "habitat", "zywotnosc")]
koty_ptaki[, c(2,4:6)]

# jednoczesne indeksowanie wierszy i kolumn
koty_ptaki[c(3,8:10), c(2,4:6)]

# wektor nazw wierszy
rownames(koty_ptaki)
# przypisanie nowych nazw dla wierszy
rownames(koty_ptaki) <- koty_ptaki$gatunek

# odwoływanie się przez nazwy wierszy i kolumn
koty_ptaki[c("Lew", "Leopard", "Jerzyk", "Strus"),
           c("waga", "dlugosc", "predkosc")]
```

---

# Zadania

- Wybierz z ramki danych `koty_ptaki` wszystkie wiersze poza ,,Sokołami'' (wiersz 11 i 12)

- Wybierz z ramki danych `koty_ptaki` tylko koty (pierwsze siedem wierszy)

- Wybierz z ramki danych `koty_ptaki` tylko kolumnę z wagą i prędkością

- Wybierz z ramki danych `koty_ptaki` wszystkie kolumny poza ostatnią

- Wybierz z ramki wiersze dla których waga jest mniejsza niż 100 oraz cztery pierwsze kolumny.

Przykładowe odpowiedzi znajdują się na stronie https://rawgit.com/pbiecek/MOOC/master/0_dane/9_zadania.html
