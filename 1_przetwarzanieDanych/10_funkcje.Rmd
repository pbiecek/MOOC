---
title: "Funkcje"
author: "pogRomcy danych"
date: "sezon 1 / odcinek 10<br><br> Wszelkie prawa zastrzeżone.<br> Wykorzystanie możliwe wyłącznie za zgodą autora.  <br><br><br><br>Naciśnij `A` by zamienić slajdy na ciągły tekst. <br> Naciśnij `T` by wyświetlić spis treści."
output:
  slidy_presentation:
    includes:
      in_header: ../tracking.html
    highlight: default
    css: ../style.css
    font_adjustment: 0
    footer: "pogRomcy danych / programowanie / funkcje"

---

# O czym jest ten odcinek

Jedną z ważniejszych cech języków programowania jest możliwość wykorzystywania rozwiązań, które my lub ktoś inny zbudował w przeszłości. Jest to możliwe dzięki jeżeli takie dobre rozwiązania zamienimy w funkcje, czyli bloki kodu które łatwo ponownie wykorzystać.

W tym odcinku nauczymy się

- Jak wywoływać funkcje?
- Jak tworzyć własne funkcje?
- Jak wywoływać funkcje z funkcji?

Do ilustracji wykorzystamy zbiór danych to `koty_ptaki` dostępny w pakiecie `SmarterPoland`.

```{r, message=FALSE, warning=FALSE}
library(SmarterPoland)
head(koty_ptaki, 3)
```

---

# Funkcje

Jest wiele powodów, dla których warto korzystać z funkcji. Trzy najistotniejsze to.

* Funkcje pozwalają na łatwe, ponowne użycie poprzednio opracowanych fragmentów kodu. Dzięki temu, możemy wykorzystywać rozwiązania, które już raz zbudowaliśmy i szybciej tworzyć kolejne. Możemy wykorzystywać rozwiązania / funkcje innych osób i dzielić się z nimi własnymi funkcjami.

* Funkcje pozwalają na logiczny podział programu, na fragmenty, które łatwiej opisać i udokumentować. Dzięki temu łatwiej zrozumieć co się dzieje w programie, gdy można poznawać poszczególne fragmenty niezależnie.

* Funkcje pozwalają skrócić długość programu. Podobne bloki kodu można zastąpić wywołaniem funkcji, przez co będzie mniej powtarzających się podobnych bloków. A im krótszy program tył łatwiej go napisać, łatwiej go zrozumieć i łatwiej znaleźć błąd.

---

# Funkcje

Przywołajmy kod programu z odcinka 8, który rysował prędkość zwierząt za pomocą liczby kropek.

Gdybyśmy chcieli ponownie wykorzystać ten sposób prezentacji danych, musielibyśmy przepisać ten kod na nowo. W tym odcinku zobaczymy jak zamienić użyteczny fragment kodu w jedną lub więcej funkcji, tak by łatwiej można było go używać.

```{r, message=FALSE, warning=FALSE}
# zamieniamy na zmienną napisową, by była dobrze wyświetlana
koty_ptaki$gatunek <- as.character(koty_ptaki$gatunek)

# Dla każdego wiersza w tabeli `koty_ptaki` wyświetlamy prędkość liczbą kropek
for (i in 1:nrow(koty_ptaki)) {
  n_kropek <- koty_ptaki[i,"predkosc"] / 5
  for (j in 1:n_kropek) {
    cat(".")
  }
  cat(" ", koty_ptaki[i,"gatunek"], "\n")
}
```

---

# Funkcje

Do tworzenia funkcji służy słowo `function`. Dla każdej funkcji należy określić listę jej argumentów oraz tak zwane ciało funkcji, czyli listę instrukcji, która funkcja wykonuje.

```{r, message=FALSE, warning=FALSE, eval=FALSE}
function(argumenty_rozdzielone_przecinkiem) {
  wyrażenie
}
```

gdzie `argumenty_rozdzielone_przecinkiem` to lista rozdzielonych przecinkiem argumentów (może być też pusta lub jednoelementowa), a `wyrażenie` to instrukcje, które mają być wykonane po wywołaniu funkcji.

Wynikiem powyższej instrukcji jest funkcja, którą należy przypisać do do zmiennej, by móc jej później używać. Dlatego najczęstsze deklaracje mają również przypisanie funkcji do zmiennej, tak jak w deklaracji poniżej. 

```{r, message=FALSE, warning=FALSE, eval=FALSE}
nazwa_funkcji <- function(argumenty_rozdzielone_przecinkiem) {
  wyrażenie
}
```

Warto jednak pamiętać, że nazwa funkcji nie jest obowiązkowa i jak się okaże często będziemy używać funkcje anonimowe, czyli bez nazwy.

---

# Funkcje z argumentami

Dla naszego przykładu z rysowaniem kropek stworzymy funkcję, którą przypiszemy do zmiennej `rysuj_kropki`. Funkcja przyjmować będzie jeden argument `n_kropek` i narysuje na ekranie dokładnie tyle kropek ile jej każemy.

Do rysowania kropek wykorzystamy pętlę `for`.

```{r, message=FALSE, warning=FALSE}
rysuj_kropki <- function(n_kropek) {
  # w pętli rysujemy n_kropek
  for (j in 1:n_kropek) {
    cat(".")
  }
}
```

Przykładowe wywołanie tej funkcji, rysujące 20 kropek, wygląda następująco.

```{r, message=FALSE, warning=FALSE}
rysuj_kropki(n_kropek = 20)
```

Jeżeli podajemy argumenty zgodnie z domyślną kolejnością, to nie musimy wskazywać ich nazw. Dotyczy to zarówno funkcji, które sami tworzymy, jak i *fabrycznych* funkcji. 

W poniższym przykładzie podajemy wartość dla argumentu i ponieważ nie ma nazwy argumentu wartość ta przypisana będzie do pierwszego (w tym przypadku jedynego) argumentu.

```{r, message=FALSE, warning=FALSE}
rysuj_kropki(20)
```

---

# Funkcje - argumenty domyślne

Jeżeli funkcja jest często wywoływana z tą samą wartością parametru, to aby oszczędzić sobie pisania, warto wskazać tę wartość jako wartość domyślną. 

Deklarując funkcję, w liście argumentów wpisujemy wartość domyślną po znaku `=`. Poniższy przykład tworzy nową funkcję (nadpisując przy okazji poprzednią deklarację) z domyślną wartością parametru `n_kropek`.

```{r, message=FALSE, warning=FALSE}
rysuj_kropki <- function(n_kropek = 20) {
  for (j in 1:n_kropek) {
    cat(".")
  }
}
```

Dzięki wartościom domyślnym, jeżeli nie podamy wartości argumentu, to zostanie on zastąpiony domyślną wartością. Bardzo wygodne w sytuacji gdy funkcja ma wiele argumentów.

```{r, message=FALSE, warning=FALSE}
rysuj_kropki() 
```

Jeżeli podana zostanie wartość argumentu, to nadpisze ona domyślną deklaracje.

```{r, message=FALSE, warning=FALSE}
rysuj_kropki(35) 
```

---

# Funkcje - obsługa różnych scenariuszy

Chcielibyśmy, by funkcje działały tak jak to zaplanowaliśmy. Rzeczywistość jest jednak taka, że funkcje często zawierają błędy lub sytuacje, o których nie pomyśleliśmy. 

Przykładowo, uruchamiając funkcję `rysuj_kropki()` z argumentem 0 spodziewalibyśmy się 0 kropek, a tym czasem...

```{r, message=FALSE, warning=FALSE}
rysuj_kropki(0) 
```

Dlaczego tak jest?

.

Otóż dlatego, że w pętli `1:n_kropek`, która znajduje się w deklaracji funkcji wektor `1:0` jest w rzeczywistości dwuelementowy.

```{r, message=FALSE, warning=FALSE}
0:1
```

Jeżeli więc chcemy by dla `n_kropek = 0` funkcja działa poprawnie musimy inaczej obsłużyć tę sytuację.

Jak zaradzić temu problemowi?

---

# Funkcje - obsługa różnych scenariuszy

Ten problem można obsłużyć na kilka sposobów, przedstawimy taki, który wymaga użycia instrukcji `if()`. 

Sprawdzimy, czy `n_kropek` jest równe lub mniejsze niż zero (jeżeli tak to nic nie rysuj), czy jest większe (rysuj kropki).

```{r, message=FALSE, warning=FALSE}
rysuj_kropki <- function(n_kropek = 20) {
  # czy liczba kropek do wyświetlenia jest większa niż zero?
  if (n_kropek > 0) {
    for (j in 1:n_kropek) {
      cat(".")
    }
  } 
}
```

Działa dla argumentu równego 0.
```{r, message=FALSE, warning=FALSE}
rysuj_kropki(0)
```

Działa dla domyślnych argumentów.
```{r, message=FALSE, warning=FALSE}
rysuj_kropki()
```

Działa dla innych wartości.
```{r, message=FALSE, warning=FALSE}
rysuj_kropki(30)
```

---

# Funkcje - więcej argumentów

Funkcje mogą mieć więcej argumentów i każdy z nich może mieć lub nie mieć wartość domyślną. 

Jeżeli wywołując funkcję podajemy argumenty w kolejności innej niż domyślna musimy podać nazwę argumentu, który określamy.

Aby to zilustrować dodajmy argument opisujący znak, który ma być rysowany. 

```{r, message=FALSE, warning=FALSE}
rysuj_kropki <- function(n_kropek = 20, znak = ".") {
  if (n_kropek > 0) {
    for (j in 1:n_kropek) {
      cat(znak)
    }
  }
}
```

I seria wywołań. Określamy drugi argument, pierwszy pozostaje domyślny, musimy wskazać nazwę.

```{r, message=FALSE, warning=FALSE}
rysuj_kropki(znak="X")
```

Określamy pierwszy argument, drugi pozostanie domyślny, nie musimy podawać nazwy.

```{r, message=FALSE, warning=FALSE}
rysuj_kropki(35)
```

Możemy argumenty podawać w dowolnej kolejności, ale musimy podawać je z nazwami.

```{r, message=FALSE, warning=FALSE}
rysuj_kropki(znak="X", n_kropek = 30)
```

---

# Funkcje - funkcja w funkcji

Tworząc nowe funkcje możemy używać w nich innych funkcji, też tych które wcześniej zdefiniowaliśmy.

Przykładowo poniżej zbudujmy funkcję rysującą wykres kropkowy dla wektora napisów i wektora wartości.

```{r, message=FALSE, warning=FALSE}
rysuj_wykres_kropkowy<- function(nazwy, wartosci) {
  # zakładamy, że oba wektory sa tej samej długości
  # funkcja seq_along(nazwy) tworzy sekwencję od 1 do długości wektora nazwy
  for (i in seq_along(nazwy)) {
    rysuj_kropki(wartosci[i])
    cat(" ", nazwy[i],"\n")
  }
}
```

I przykładowe wywołanie.
```{r, message=FALSE, warning=FALSE}
rysuj_wykres_kropkowy(koty_ptaki$gatunek, koty_ptaki$predkosc/5)
```

Warto utrzymywać każdą z funkcji o niewielkiej długości, by łatwo było opisać i zapamiętać co ta funkcja robi.
Z tego też powodu warto funkcje dobrze nazywać i dokumentować. 

---

# Funkcje zgłaszające błędy

W funkcji z poprzedniego slajdu założyliśmy, że oba wektory są równej długości.

A co jeżeli nie są?
Może użytkownik nie wie, że powinny być.

Takie założenia warto sprawdzać, np. używając instrukcji `if()`. Jeżeli założenie jest ważne i bez jego spełnienia nie można kontynuować działania funkcji, to możemy przerwać działanie funkcji i zwrócić błąd poleceniem `stop()`.


```{r, message=FALSE, warning=FALSE}
rysuj_wykres_kropkowy <- function(nazwy, wartosci) {
  # czy oba argumenty mają równą długość?
  if (length(nazwy) != length(wartosci)) {
    # funkcja stop() przerywa działanie funkcji
    stop("Argumenty mają różną długość! ", length(nazwy), " oraz ", length(wartosci))
  }
  # jeżeli wszystkie warunki są spełnione to można kontynuować wykonanie funkcji
  for (i in seq_along(nazwy)) {
    rysuj_kropki(wartosci[i])
    cat(" ", nazwy[i],"\n")
  }
}
```

Co się stanie, jeżeli wywołamy tę funkcję z niepoprawnymi argumentami.

```{r, message=FALSE, warning=FALSE, eval=FALSE}
rysuj_wykres_kropkowy(koty_ptaki$gatunek, 5)
```
```
Error in rysuj_wykres_kropkowy(koty_ptaki$gatunek, 5) : 
  Argumenty mają różną długość! 13 oraz 1
```

---

# Parametry przekazywane dalej

W liście argumentów funkcji dozwolony jest też specjalny argument `...`. Używając go można przekazać wszystkie pozostałe argumenty dalej, do funkcji wewnętrznych.

W przykładzie poniżej operator `...` pojawia się w dwóch miejscach, w liście argumentów funkcji `rysuj_wykres_kropkowy()` i w liście argumentów funkcji `rysuj_kropki()`. 

Wszystkie argumenty dla funkcji `rysuj_wykres_kropkowy()`, których nazwa jest różna od `nazwy` i `wartosci` będą przekazane dalej do funkcji `rysuj_kropki()`.

```{r, message=FALSE, warning=FALSE}
rysuj_wykres_kropkowy <- function(nazwy, wartosci, ...) {
  for (i in seq_along(nazwy)) {
    rysuj_kropki(wartosci[i], ...)
    cat(" ", nazwy[i],"\n")
  }
}
```

Zilustrujmy to na przykładzie. Wywołujemy `rysuj_wykres_kropkowy()` z trzema argumentami, trzeci, czyli `znak = "X"` zostanie przekazany do `rysuj_kropki()` dzięki czemu na wykresie pojawią się znaki `X`.

```{r, message=FALSE, warning=FALSE}
rysuj_wykres_kropkowy(nazwy = LETTERS[1:5], wartosci = 1:5, znak = "X")
```


---

# Funkcje zwracające wartości

Funkcje zawdzięczają swoją nazwę temu, że zwracają wartości.

Ale te funkcje, które powyżej stworzyliśmy wypisywały wyniki na ekranie. 

Domyślnie wynikiem funkcji jest wynik ostatniego wyrażenia w funkcji. Innym sposobem na wskazanie wyniku jest użycie funkcji `return()`, która przerywa działanie funkcji i jako wynik zwraca wartość argumentu funkcji `return()`.

Zilustrujmy to na poniższym przykładzie. Funkcja `suma_n_liczb_losowych()` losuje `n` losowych liczb i jako wynik zwraca ich sumę. 

Jeżęli jednak jako argument podana jest wartość mniejsza niż 1, to działanie funkcji jest przerywane i jako wynik zwracana jest wartość 0.

```{r, message=FALSE, warning=FALSE}
suma_n_liczb_losowych <- function(n = 10) {
  if (n < 1) {
    return(0)
  } 
  sum(runif(n))
}
```

Wywołajmy tę funkcję. Jeżeli jej wynik nie zostanie przypisany do żadnej zmiennej to zostanie wyświetlony na ekranie. 

```{r, message=FALSE, warning=FALSE}
suma_n_liczb_losowych(10) 
```

I wynik, gdy argument jest mniejszy niż 1.

```{r, message=FALSE, warning=FALSE}
suma_n_liczb_losowych(-1) 
```

---

# Podsumowanie instrukcji R

W tym odcinku omawialiśmy funkcje, z argumentami, bez argumentów, z wynikami i bez wyników.

Poniżej znajduje się zestawienie wszystkich wykorzystanych w tym odcinku instrukcji.

```{r, eval=FALSE}
# Tworzymy funkcję wyświetlającą n_kropek kropek
rysuj_kropki <- function(n_kropek) {
  for (j in 1:n_kropek) {
    cat(".")
  }
}

# Funkcje można wywołać podając nazwę argumentu lub nie
rysuj_kropki(n_kropek = 20)
rysuj_kropki(20)

# Tworzymy funkcję z domyślną wartością argumentu n_kropek
rysuj_kropki <- function(n_kropek = 20) {
  for (j in 1:n_kropek) {
    cat(".")
  }
}

# Dodajemy obsługę argumentów mniejszych niż 1. Wystarczy instrukcja if()
rysuj_kropki <- function(n_kropek = 20) {
  if (n_kropek > 0) {
    for (j in 1:n_kropek) {
      cat(".")
    }
  } 
}
```

---

# Podsumowanie instrukcji R

Poniżej znajduje się zestawienie wszystkich wykorzystanych w tym odcinku instrukcji.

```{r, eval=FALSE}
# Dodajemy drugi argument, określający jakie znaki mają być rysowane. Domyślnie kropki
rysuj_kropki <- function(n_kropek = 20, znak = ".") {
  if (n_kropek > 0) {
    for (j in 1:n_kropek) {
      cat(znak)
    }
  }
}

# Możemy podawać argumenty w dowolnej kolejności o ile podamy ich nazwy
rysuj_kropki(znak="X", n_kropek = 30)

# Wewnątrz jednej funkcji wywołujemy inną
rysuj_wykres_kropkowy<- function(nazwy, wartosci) {
  for (i in seq_along(nazwy)) {
    rysuj_kropki(wartosci[i])
    cat(" ", nazwy[i],"\n")
  }
}

# W przypadku gdy argumenty są złe, zatrzymujemy wykonanie funkcją stop()
rysuj_wykres_kropkowy <- function(nazwy, wartosci) {
  # czy oba argumenty mają równą długość?
  if (length(nazwy) != length(wartosci)) {
    stop("Argumenty mają różną długość! ", length(nazwy), " oraz ", length(wartosci))
  }
  for (i in seq_along(nazwy)) {
    rysuj_kropki(wartosci[i])
    cat(" ", nazwy[i],"\n")
  }
}
```

---

# Podsumowanie instrukcji R

Poniżej znajduje się zestawienie wszystkich wykorzystanych w tym odcinku instrukcji.

```{r, eval=FALSE}
# Argumenty możemy przekazywać dalej używając ...
rysuj_wykres_kropkowy <- function(nazwy, wartosci, ...) {
  for (i in seq_along(nazwy)) {
    rysuj_kropki(wartosci[i], ...)
    cat(" ", nazwy[i],"\n")
  }
}

# Przykładowe wywołanie, ostatni argument zostanie przekazany dalej
rysuj_wykres_kropkowy(nazwy = LETTERS[1:5], wartosci = 1:5, znak = "X")

# Funkcja która zwraca wynik liczbowy
suma_n_liczb_losowych <- function(n = 10) {
  if (n < 1) {
    return(0)
  } 
  sum(runif(n))
}

# Dwa przykładowe wywołania, zwracają wynik różnym scenariuszem, poprzez ostatnią wartość
suma_n_liczb_losowych(10) 
# poprzez wywołanie funkcji return()
suma_n_liczb_losowych(-1) 
```

---

# Zadania

* Napisz funkcję, która otrzymuje argument liczbowy a następnie wypisuje na ekran wartości od argumentu do jeden.
* Napisz funkcję, przyjmuje argument liczbowy `n` a następnie rysuje kwadrat o boku `n` wypełniony znakami `X`.
* Napisz funkcję, przyjmuje argument liczbowy `n` a następnie rysuje kwadrat o boku `n` ze znakami `X` na brzegu i pusty w środku.

Przykładowe odpowiedzi znajdują się na stronie https://rawgit.com/pbiecek/MOOC/master/0_dane/9_zadania.html
