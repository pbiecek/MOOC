---
title: "Indeksowanie ramek danych i wektorów"
author: "pogRomcy danych"
date: "sezon 1 / odcinek 7 <br><br><br><br>Naciśnij `A` by zamienić slajdy na ciągły tekst. <br> Naciśnij `T` by wyświetlić spis treści."
output:
  slidy_presentation:
    includes:
      in_header: ../tracking.html
    highlight: default
    css: ../style.css
    font_adjustment: 0
    footer: "pogRomcy danych / eksploracja danych / indeksowanie"
---

# O czym jest ten odcinek

Dane z którymi będziemy pracować mają najczęściej format tabeli lub wektora. 
Jedną z podstawowych operacji na tabelach oraz wektorach jest wybieranie podzbioru wierszy, kolumn lub wartości.

W tym odcinku dowiemy się

- Jak tworzyć wektory
- Jak indeksować wartości z wektora
- Jak wybierać wiersze z ramki danych
- Jak wybierać kolumny z ramki danych
- Jak wybierać wiersze i kolumny
- Jak indeksować wiersze i kolumny używając nazw lub wartości logicznych

---

# Wektory

Jednym z podstawowych rodzajów danych w programie R są wektory. 

Wektory mogą zawierać liczby, napisy, wartości logiczne lub inne typy. Zacznijmy od wektorów wartości liczbowych.

W programie R nawet jedna wartość jest wektorem, tyle że małym, jednoelementowym.

```{r}
4
```

Dłuższe wektory można tworzyć np funkcją `c()`, która pozwala na sklejenie kilku wartości w jeden wektor. 

Przykładowa instrukcja tworząca wektor o trzech elementach.

```{r}
c(3, 4, 5)
```

W programowaniu i analizie danych bardzo często wykorzystuje sie wektory kolejnych wartości liczbowych. Takie wektory mają nawet specjalną nazwę *sekwencje*.

Sekwencje kolejnych liczb można stworzyć operatorem `:`. Jeżeli chcemy zbudować sekwencję liczb równie odległych od siebie, ale z krokiem innym niż 1, to wygodnie jest wykorzystać funkcję `seq()`.

```{r}
2:7
seq(from = 3, to = 15, by = 2)
```

---

# Wektory

Używając funkcji `c()` można tworzyć wektory wartości logicznych (z dwoma możliwymi stanami PRAWDA/FAŁSZ oznaczanymi `TRUE`/`FALSE`), wektory napisów oraz innego rodzaju wartości.

Aby wykorzystać wektor później, trzeba go przypisać do zmiennej. Można to zrobić używając operatora `->` lub `=`.
Jeżeli chcemy wyświetlić zawartość zmiennej to wystarczy wpisać ją do konsili i nacisnąć ENTER.

```{r, message=FALSE, warning=FALSE}
co_drugi <- c(TRUE, FALSE, TRUE, FALSE, TRUE, FALSE)
co_drugi

literki <- c("alfa", "beta", "gamma", "delta")
literki
```

W dalszym ciągu tego odcinka wykorzystamy wektor kolejnych liter w języku angielskim zapisany w zmiennej `LETTERS`. Użyjemy tego wektora do ćwiczeń w indeksowaniu.

```{r, message=FALSE, warning=FALSE}
LETTERS
```

---

# Indeksowanie wektora

Indeksowanie oznacza wybieranie określonych wartości. Wartości wybieramy wskazując ich indeksy. Brzmi jak masło maślane? 

Wektor to ciąg elementów. Pierwszy z tych elementów ma indeks 1, kolejny 2, kolejny 3 i tak aż do ostatniego elementu. Indeks ostatniego elementu to jednocześnie długość wektora. Można ją sprawdzić funkcją `length()`.

```{r, message=FALSE, warning=FALSE}
length(LETTERS)
```

Aby odwołać się do określonych indeksów wektora należy użyć operatora `[]`. Wewnątrz nawiasów kwadratowych podaje się indeks elementu, do którego chcemy się odwołać.

```{r, message=FALSE, warning=FALSE}
# pierwszy element wektora
LETTERS[1]
# piąty
LETTERS[5]
# ostatni element wektora
LETTERS[26]
# zamiast podawać wartość 26 można wstawić funkcję, która jako wynik zwróci długość wektora
LETTERS[length(LETTERS)]
```

---

# Indeksowanie wektora

Odwołując się do wektorów, możemy podać indeks więcej niż jednej wartości. Zasada jest jednak taka, że indeksy muszą być wektorem. Do tego przyda nam się już poznana funkcja `c()`.

Przykładowo, aby wybrać pierwszy, piąty i ostatni element z wektora LETTERS musimy wpierw skonstruować wektor z tymi trzema indeksami.

```{r, message=FALSE, warning=FALSE}
LETTERS[c(1,5,26)]
```

Równoważnie można najpierw stworzyć wektor indeksów a następnie wykorzystać go do indeksowania wektora `LETTERS`.

```{r, message=FALSE, warning=FALSE}
indeksy <- c(1, 5, 26)
LETTERS[indeksy]
```

Aby wybrać więcej elementów z wektora wygodnie jest wykorzystać sekwecje.

```{r, message=FALSE, warning=FALSE}
# dziesięć pierwszych liter
LETTERS[1:10]
# pięć pierwszych i pięć ostatnich
LETTERS[c(1:5, 21:26)]
# co druga litera, indeksujemy sekwencją od 1 do 26 z krokiem co 2
coDruga <- LETTERS[seq(from = 1, to = 26, by = 2)]
coDruga
```

---

# Indeksowanie wektora

Sekwencje wartości nie muszą być rosnące. Można je wykorzystać np. do tego by odwrócić kolejność elementów w wektorze.

```{r, message=FALSE, warning=FALSE}
10:1
LETTERS[10:1]
```

Elementy wektora można również indeksować warunkiem logicznym. 

W poniższym przykładzie instrukacja `LETTERS > "K"` tworzy wektor wartości logicznych weryfikujących czy koljna litera jest większa czy mniejsza od `K` (w porządku leksykograficznym),

Taki wektor wartości logicznych można wykorzystać do indeksowania wektora `LETTERS`.

```{r, message=FALSE, warning=FALSE}
LETTERS > "K"
# tylko litery spełniające określony warunek
# w tym przypadku litery występujące po literze 'K'
LETTERS[LETTERS > "K"]
```

---

# Zadania

- Zbuduj sekwencję dziesięciu koljnym małych liter alfabetu łacińskiego.

- Zbuduj sekwencję dziesięciu kolejnych liczb nieparzystych zaczynając od 3.

- Z wektora `LETTERS` wybierz litery na pozycjach 5, 10, 15, 20 i 25.

- Wypisz wartości wektora `LETTERS` od końca.

---

# Ptaki vs koty

Do pracy nad wybieraniem wierszy i kolumn wykorzystamy niewielki zbiór danych o kotach i ptakach.
Siedem kolumn i trzynaście wierszy to dobry zbiór do ćwiczeń.

```{r, message=FALSE, warning=FALSE}
library(SmarterPoland)
koty_ptaki
```

---

# Wybieranie wierszy z ramki danych

Aby odwoływać się do wierszy lub kolumn ramki danych można wykorzystać operator `[,]`. 
Przed przecinkiem należy wpisać indeksy wierszy.

Przykładowo, odwołanie się do trzeciego wiersza

```{r, message=FALSE, warning=FALSE}
koty_ptaki[3,]
```

Aby odwołać się do kilku kolejnych wierszy można wykorzystać sekwencję zbudowaną z operatorem `:`.
Wiersze od 8 do 10 można wyłuskać następująco

```{r, message=FALSE, warning=FALSE}
koty_ptaki[8:10,]
```

Funkcja `c()` skleja wartości i sekwencje  wektor, który można następnie wykorzystać w indeksowaniu wierszy.
Poniższa instrukcja wyłuskuje wiersze 3, 8, 9 i 10.

```{r, message=FALSE, warning=FALSE}
koty_ptaki[c(3,8:10),]
```

Funkcjami `head()` i `tail()` wyłuskuje pierwsze lub ostatnie 6 wierszy ze zbioru danych.

```{r, message=FALSE, warning=FALSE}
head(koty_ptaki)
tail(koty_ptaki)
```

---

# Wybieranie kolumn z ramki danych

Podobnie jak wiersze, można indeksować kolumny. Aby wyłuskać drugą kolumnę można wskazać jej numer po przecinku.

```{r, message=FALSE, warning=FALSE}
koty_ptaki[,2]
```

Wybranie jednej kolumny powoduje, że jako wynik otrzymujemy nie ramkę danych ale wektor.
Aby temu zapobiec i jako wynik wciąż mieć ramkę danych, należy dodać do indeksowania argument `drop=FALSE`.

```{r, message=FALSE, warning=FALSE}
koty_ptaki[,2, drop=FALSE]
```

---

# Wybieranie kolumn z ramki danych

Aby wybrać więcej kolumn można wykorzystać funkcję `c()`, tak jak w przypadku indeksowania wierszy.

```{r, message=FALSE, warning=FALSE}
koty_ptaki[,c(2,3:4)]
```

---

# Wybieranie podramki z ramki danych

Możemy jednocześnie odwoływać się do wierszy i kolumn w ramce danych, wybierając jej podramkę.

```{r, message=FALSE, warning=FALSE}
koty_ptaki[c(3,8:10),c(2,3:4)]
```

---

# Wybieranie podramki z ramki danych nazwami

Dodajmy nazwy wierszy dla naszej ramki.

```{r, message=FALSE, warning=FALSE}
rownames(koty_ptaki) <- koty_ptaki[,1]
head(koty_ptaki, 3)
```

[TODO] warto pokazac jak pozbyc sie nazw wierszy
rownames(koty_ptaki) <- NULL

Tak wiersze jak i kolumny można wskazywać nie tylko indeksami liczbowymi, ale również wskazując nazwy wierszy i/lub kolumn.

```{r, message=FALSE, warning=FALSE}
koty_ptaki[c("Lew", "Leopard", "Jerzyk", "Strus"),
           c("waga", "dlugosc", "predkosc")]
```

Do wskazanej kolumny można odwoływać się przez jej nazwę również używając operatora `$`.

```{r, message=FALSE, warning=FALSE}
koty_ptaki$waga
```

---

# Wybieranie podramki z ramki danych nazwami

Do indeksowania macierzy można wykorzystywać też wektory wartości logicznych TRUE/FALSE. W tym przypadku wybrane będą tylko te wiersze / kolumny, którym odpowiada wartość TRUE.

```{r, message=FALSE, warning=FALSE}
koty_ptaki$predkosc > 100
grepl(colnames(koty_ptaki), pattern = "a")

koty_ptaki[koty_ptaki$predkosc > 100,
           grepl(colnames(koty_ptaki), pattern = "a")]
```


---

# Zadania


