---
title: "Cechy logiczne"
author: "pogRomcy danych"
date: "sezon 1 / odcinek 13 <br><br> Przemysław Biecek @ Uniwersytet Warszawski<br><br><br>Naciśnij `A` by zamienić slajdy na ciągły tekst. <br> Naciśnij `T` by wyświetlić spis treści."
output:
  slidy_presentation:
    includes:
      in_header: ../tracking.html
    highlight: default
    css: ../style.css
    font_adjustment: 0
    footer: "pogRomcy danych / przetwarzanie / zmienne logiczne"

---

# O czym jest ten odcinek

Analizując dane spotkamy się z różnymi rodzajami zmiennych. Omówiliśmy ilościowe i jakościowe. Specyficzną odmianą cech jakościowych są cechy logiczne, przyjmujące wartości logiczne prawda / fałsz.

W tym odcinku nauczymy się:

- jakie zmienne / cechy określa się terminem *cechy logiczne*,
- jakie podstawowe operacje można wykonywać na cechach logicznych,
- jak podsumowywać / opisywać cechy logiczne.

Do ilustracji tych zagadnień wykorzystamy dwa zbiory danych. Pierwszy, mały zbiór danych, to `koty_ptaki` a drugi, znacznie większy, to `auta2012`, oba dostępne w pakiecie `PogromcyDanych`.

---

# Co to znaczy: cecha logiczna

Cechy logiczne to takie, które opisują jedną z dwóch wartości logicznych prawda/fałsz. 
Przykładowo: czy wzrost jest większy niż 150 cm, czy pada deszcz, czy pacjent przeżył 5 lat po operacji itp.

Zmienne logiczne często powstają w wyniku przetwarzania zmiennych ilościowych lub jakościowych. 
Mając wykształcenie opisane przez trzy poziomy, można skonstruować sztuczną cechę: czy ma wykształcenie wyższe. 
A mając wzrost opisany jako cecha ilościowa można skonstruować cechę logiczną, czy jest wyższy niż 150 cm.

Zmienne logiczne można traktować jak zmienne jakościowe, przyjmują bowiem wartości z dwuelementowego słownika. 
Podobnie jak dla wartości jakościowych, tak i dla wartości logicznych można wyznaczać tablicę liczebności.

Dla zmiennych logicznych dostępnych jest kilka dodatkowych operacji logicznych, których nie można wykonać na typowych zmiennych jakościowych.

---

# Logika trójwartościowa

Napisaliśmy wcześniej, że wartości logiczne przyjmują wartości `TRUE` (logiczna prawda) lub `FALSE` (logiczny fałsz). 
Jednak równocześnie każdy rodzaj zmiennych w programie R może również przyjmować wartości nieustaloną `NA`. 
W gruncie rzeczy wartości logiczne operują zatem w logice trójwartościowej.

Tworząc wartości logiczne często wykorzystuje się operatory logiczne `>` (większy), `>=` (większy równy), 
`==` (równy), `<=` (mniejszy równy), `<` (mniejszy). Gdy porównuje się takim operatorem wartość nieustaloną `NA` 
to wynik również jest wartością nieustaloną.

```{r}
c(1,5,7,3,8, NA) <= 4
c("Ala", "Ola", "Ula", NA, "Ela", "Ola") == "Ola"
```

Tworząc wektory wartości logicznych zamiast pełnych nazw `TRUE` i `FALSE` można również korzystać ze skrótów `T` i `F`.

```{r}
c(T, F, NA, TRUE, FALSE)
```

Specjalnymi operatorami dla wartości logicznych są `|` (logiczne lub) oraz `&` (logiczne i). Pierwszy z nich zwraca 
jako wynik wartość `TRUE` jeżeli którykolwiek argument jest prawdziwy. Drugi zwraca jako wynik wartość `TRUE` jeżeli oba argumenty są prawdziwe.

```{r, warning=FALSE}
TRUE | FALSE
(4 > 2) | ("A" == "a")
```

---

# Tabliczka logicznego dodawania i logicznego mnożenia

Przydatną do przedstawienia możliwych wyników operatora `|` jest tabliczka logicznego dodawania. Aby ją przedstawić 
zdefiniujmy wektor zawierający każdą z trzech możliwych wartości logicznych.

```{r, warning=FALSE}
(TRUE_FALSE_NA <- c(TRUE, FALSE, NA))
```

Funkcja `outer()` jako argumenty przyjmuje dwa wektory a następnie dla każdej pary wartości z pierwszego i drugiego 
wektora stosuje funkcję, która jest trzecim argumentem. Kolejne dwie linie dodają nazwy wierszy i kolumn, tak 
by na koniec wyprodukować ładnie wyglądającą tabliczkę logicznego dodawania. Jeżeli którykolwiek z argumentów 
ma wartość logicznej prawdy to wynikiem `lub` jest logiczna prawda.

```{r, warning=FALSE}
tabliczka_dodawania <- outer(TRUE_FALSE_NA, TRUE_FALSE_NA, "|")
rownames(tabliczka_dodawania) <- TRUE_FALSE_NA
colnames(tabliczka_dodawania) <- TRUE_FALSE_NA
tabliczka_dodawania
```

W podobny sposób możemy zbudować tabliczkę logicznego mnożenia, używając operatora `&`

```{r, warning=FALSE}
tabliczka_mnozenia <- outer(TRUE_FALSE_NA, TRUE_FALSE_NA, "&")
rownames(tabliczka_mnozenia) <- TRUE_FALSE_NA
colnames(tabliczka_mnozenia) <- TRUE_FALSE_NA
tabliczka_mnozenia
```

Warto zwrócić uwagę na wynik (`TRUE | NA`). Wynikiem jest wartość `TRUE`, poinieważ bez znaczenia czy wartość nieokreślona okazałaby się prawdziwa czy fałszywa, jej logiczna suma z wartością `TRUE` dałoby wartość `TRUE`. Na podobnej zasadzie `FALSE & NA` zwraca wartość `FALSE`.

W programie R występują również dłuższe postacie operatorów `|` i `&` czyli `||` i `&&`. Pomiędzy formą dłuższą i krótszą występują dwie różnice. Forma krótsza pracuje na wektorach i wykonuje operacja element wektora po elemencie, podczas gdy forma dłuższa wykonuje operacje jedynie na pierwszych elementach wektorów i jako wynik zwraca jednoelementową wartość `TRUE` lub `FALSE`. Druga różnica dotyczy zaawansowanych zastosowań, długa forma nie wykonuje ewaluacji prawego argumentu, jeżeli nie jest to niezbędne. 

Przykładowo pierwsza linia poniższego przykładu wykona się poprawnie, ponieważ do określenia wyniku nie potrzebna jest ewaluacja funkcji `cat()`. Drugi przykład wykona funkcję `cat()` oraz zasygnalizuje błąd, ponieważ nie sposób wyniku funckji `cat()` logicznie dodać do wartości `TRUE`.

```{r, warning=FALSE, eval=FALSE}
TRUE || cat("Jestem tutaj !!!")
## [1] TRUE
TRUE | cat("Jestem tutaj !!!")
## Jestem tutaj !!!
## Error in TRUE | cat("Jestem tutaj !!!") : 
##   operations are possible only for numeric, logical or complex types
```


---

# Wczytanie danych

Dane od których rozpoczniemy przykłady to `koty_ptaki` z pakietu `PogromcyDanych`. 
Aby te dane wczytać, wystarczy włączyć pakiet, instrukcja jak to zrobić znajduje się w odcinku 2.

Włączmy pakiet i użyjmy funkcji `head()` by wyświetlić pierwsze sześć wierszy. 

```{r, warning=FALSE, message=FALSE}
library(PogromcyDanych)
head(koty_ptaki)
```



---

# Statystyki opisowe

Na bazie zmiennej `druzyna` zbudujmy zmienną logiczną `czy_to_kot`, a na bazie zmiennej `waga` zbudujemy zmienną logiczną `czy_jest_ciezki`.

```{r, warning=FALSE}
czy_to_kot <- koty_ptaki$druzyna == "Kot"
czy_jest_ciezki <- koty_ptaki$waga >= 10
```

Traktując zmienną logiczną jak dwuwartościową zmienną jakościową, możemy używać na niej 
np. funkcji do tabel liczebności, zarówno jednowymiarowych jak i dwuwymiarowych.

Patrząc na wyniki dla tabeli liczebności dla dwóch zmiennych jest tylko jeden zwierzak 
w tym zbiorze danych, który jest cięższy niż 10kg, ale nie jest kotem.

```{r, warning=FALSE}
table(czy_to_kot)
table(czy_jest_ciezki)
table(czy_to_kot, czy_jest_ciezki)
```

---

# Operator negacji

Innym przydatnym operatorem jest logiczna negacja `!`. Zamienia ona wartość logicznej prawdy na fałsz i odwrotnie.

```{r, warning=FALSE}
czy_to_kot
!czy_to_kot
```

W operacjach arytmetycznych wartości logiczne TRUE są przekształcane na 1 a wartości FALSE na 0. 
Dzięki czemu, jeżeli chcemy policzyć ile wartości ma wartość TRUE to wystarczy wartość wektora zsumować. 
Poniższy przykład pokazuje ile jest kotów i nie kotów w zbiorze danych.

```{r, warning=FALSE}
sum(czy_to_kot)
sum(!czy_to_kot)
```

Taki wektor wartości logicznych można mnożyć z wektorem wartości liczbowych. Poniższa instrukcja 
używa takiej operacji do policzenia sumy wagi wszystkich kotów w zbiorze danych. Mnożenie 
przez wektor wartości logicznych powoduje wyzerowanie określonych wartości.

```{r, warning=FALSE}
czy_to_kot * koty_ptaki$waga
sum(czy_to_kot * koty_ptaki$waga)
```

---

# Wczytanie danych

Zbiór danych `koty_ptaki` składa się z 13 wierszy. Można cały ten zbiór danych wyświetlić na ekranie. 
Nie zawsze potrzebujemy więc specjalnych statystyk opisowych by zrozumieć co się dzieje w takich małych zbiorach danych.

Dlatego dalsze ćwiczenia ze zmiennymi logicznymi przeprowadzimy na znacznie większym zbiorze danych `auta2012` z 
ponad 200 tysiącami wartości, który również znajduje się w pakiecie `PogromcyDanych`.

Opis tego zbioru danych znaleźć można w odcinku http://pogromcydanych.icm.edu.pl/materials/1_przetwarzanie/0_dane.html

Wczytajmy ten zbiór danych i przyjrzyjmy się trzem pierwszym wierszom. 

```{r, warning=FALSE, message=FALSE}
library(PogromcyDanych)
head(auta2012, 3)
```

---

# Statystyki opisowe

Wykorzystajmy wartości logiczne oraz funkcję `table()`, aby sprawdzić ile aut w naszych danych jest 
zarejestrowanych w Polsce oraz ile z nich zostało wyprodukowanych przed 2007 rokiem.
Tak jak w przypadku zmiennych jakościowych możemy wykorzystać funkcję `prop.table()` do wyznaczenia frakcji / procentów.

Co może być zaskakujące, mniej niż połowa ofert ma zadeklarowany kraj aktualnej rejestracji jako Polska.

```{r, warning=FALSE}
pochodziZPolski <- auta2012$Kraj.aktualnej.rejestracji == "Polska"
table(pochodziZPolski)
prop.table(table(pochodziZPolski)) * 100

starszyNiz5Lat <- auta2012$Rok.produkcji < 2007
table(starszyNiz5Lat)
prop.table(table(starszyNiz5Lat)) * 100
```

---

# Zadania:

+ Sprawdź ile samochodów ma cenę ofertową poniżej 2 000 pln.

+ Sprawdź jaki procent samochodów ma silniki o pojemności ponad 1500 cm3.

Przykładowe odpowiedzi znajdują się na stronie http://pogromcydanych.icm.edu.pl/materials/1_przetwarzanie/9_zadania.html

---

# Testy dla typów i wartości

Porównując wartości należy uważać na wartości nieokreślone, które nie zawsze zachowują się zgodnie z naszą intuicją, ale zawsze logicznie.

Przykładowo, operator `!=` testuje czy wartości są różne (to negacja operatora `==`). Jak 
sprawdzić czy wartości w wektorze są różne od wartości brakującej `NA`? Zacznijmy od przykładu jak tego nie robić.

```{r}
czyOkreslonyPrzebieg <- auta2012$Przebieg.w.km != NA
head(auta2012$Przebieg.w.km)
head(czyOkreslonyPrzebieg)
```

Wynikiem porównania `!= NA` jest wektor wartości `NA`. Jest tak ponieważ jeżeli prawa część 
porównania jest nieznana to też nie wiadomo czy wartość 41000 jest od niej różna czy nie.

Aby sprawdzić, czy dana wartość jest wartością brakującą możemy wykorzystać funkcję `is.na()`. 
Jako wynik zwraca TRUE jeżeli testowana wartość to NA i FALSE w przeciwnym przypadku.

Możemy użyć tej funkcji by policzyć procent wartości, dla których nie ma brakujących danych.

```{r}
czyOkreslonyPrzebieg <- !is.na(auta2012$Przebieg.w.km)
head(czyOkreslonyPrzebieg)
# procent
mean(czyOkreslonyPrzebieg) * 100
```

Funkcji do testowania jest więcej, zaczynają one swoje nazwy od `is.`, wystarczy więc wpisać 
te trzy znaki do konsoli i nacisnąć klawisz TAB by zobaczyć ich listę. Część z nich sprawdza 
czy zmienna jest określonego typu, np. `is.factor()`, `is.numeric()`, część sprawdza czy 
zmienna ma określone wartości np. `is.na()` czy `is.nan()`.

---

# Logiczne 'i' oraz logiczne 'lub'

Ponieważ operatory logicznego `lub` oraz `i` są często wykorzystywane poćwiczmy je jeszcze na zbiorze danych o samochodach. 
Zdefiniujmy dwa wektory wartości logicznych, weryfikujących czy samochód jest aktualnie zarejestrowany w Polsce 
oraz czy jest starszy niż pięć lat, a więc wyprodukowany przed rokiem 2007.

```{r, warning=FALSE}
pochodziZPolski <- auta2012$Kraj.aktualnej.rejestracji == "Polska"
starszyNiz5Lat  <- auta2012$Rok.produkcji < 2007
```

Teraz policzymy logiczną sumę oraz iloczyn obu wektorów. Następnie użyjemy funkcji table aby przedstawić wyniki.

```{r, warning=FALSE}
pochodziZPolskiIStarszyNiz5Lat   <- pochodziZPolski & starszyNiz5Lat
pochodziZPolskiLubStarszyNiz5Lat <- pochodziZPolski | starszyNiz5Lat
# Tabela obu zmiennych
table(pochodziZPolski, starszyNiz5Lat)
# logiczne i
table(pochodziZPolskiIStarszyNiz5Lat)
# logiczne lub
table(pochodziZPolskiLubStarszyNiz5Lat)
```

---

# Zadania:

+ Sprawdź ile samochodów zarejestrowanych w Polsce ma cenę ofertową poniżej 2 000 pln.

+ Sprawdź jaki procent samochodów ma silniki o pojemności ponad 1500 cm3 oraz jest napędzanych olejem napędowym.

Przykładowe odpowiedzi znajdują się na stronie http://pogromcydanych.icm.edu.pl/materials/1_przetwarzanie/9_zadania.html


