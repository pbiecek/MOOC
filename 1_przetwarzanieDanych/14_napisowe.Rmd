---
title: "Cechy napisowe"
author: "pogRomcy danych"
date: "sezon 1 / odcinek 14 <br><br> Wszelkie prawa zastrzeżone.<br> Wykorzystanie możliwe wyłącznie za zgodą autora.  <br><br><br><br>Naciśnij `A` by zamienić slajdy na ciągły tekst. <br> Naciśnij `T` by wyświetlić spis treści."
output:
  slidy_presentation:
    includes:
      in_header: ../tracking.html
    highlight: default
    css: ../style.css
    font_adjustment: 0
    footer: "pogRomcy danych / przetwarzanie / zmienne napisowe"

---


# O czym jest ten odcinek

Analizując dane spotkamy się z różnymi rodzajami zmiennych. 
Bardzo często są to napisy lub zmienne, które chcemy do napisów przekształcić (np. data, którą można przekształcić do napisy by wyłuskać roki miesiąc).

W tym odcinku nauczymy się

- Jak przekształcać zmienne na i z napisów?
- Jakie podstawowe operacje można wykonywać na napisach?
- Jak podsumowywać / opisywać napisy?

Do ilustracji tych zagadnień wykorzystamy dwa zbiory danych. Pierwszy, mały zbiór danych, to `koty_ptaki` a drugi, znacznie większy, to `auta2012`, oba dostępne w pakiecie `SmarterPoland`.

---

# Co to znaczy: napisy

Osoby mające doświadceznie w pracy z takimi językami jak C++ czy Java są przyzwyczajone do rozdizały typów na znaki, napisy (łańcuchy znaków) i wektory napisów. W programie R nie ma tego podziału, są tylko wektory napisów. 

Wektor może być jednoelementowy i długość tego jednego elementu może wynosić jeden, ale wciąż to wektor napisów. Takie wektory oznaczane są klasą `character`.

```{r}
class("A")
```

Napisy spotkać można w różnych kontekstach. Najbardziej naturalnym jest taki, że w zbiorze danych były zebrae wypowiedzi. Np. pobierając dane z Twittera, jedną ze zmiennych opisujących pojedyńcze ćwierknięcie jest treść tweetu czyli napis o długości do 140 znaków.

Napisy pojawiają się też, gdy wczytywane są dane ilościowe lub jakościowe, ale z jakiegoś powodu w procesie wczytywania dane te wczytały się jako napisy (np. przez źle określone formatowanie). W takim przypadku, często napisy przekształcamy na porządany typ, np. ilościowy, jakościowy, datę itp.

```{r}
as.numeric("2012")     # konwersja na liczbę
as.factor(c("A", "B", "A", "A")) # konwersja na zmienną jakościową
as.Date("2012-01-01")  # konwersja na datę
```

---

# Wczytanie danych

Dane od których rozpoczniemy przykłady to `koty_ptaki` z pakietu `SmarterPoland`. Aby te dane wczytać, wystarczy włączyć pakiet, instrukcja jak to zrobić znajduje się w odcinku 2.

Włączmy pakiet i użyjmy funkcji `head()` by wyświetlić pierwsze sześć wierszy.

```{r, warning=FALSE, message=FALSE}
library(SmarterPoland)
head(koty_ptaki)
```

Każdy wiersz opisuje jeden gatunek. Jak wiemy z poprzedniego odcinka, zmienna gatunek, habitat i drużyna to zmienne jakościowe. Przekształcimy je na napisy aby zademonstrować podstawowe operacje na napisach.

---

# Konwersja na napis

Wybierzmy kolumnę `habitat`. W zbiorze danych `koty_ptaki` jest to zmienna jakościowa. Użyjemy funkcji `as.character()` by ją przekształcić na napis. Otrzymane napisy zapiszemy w kolumnie `habitat_napis`.

```{r, warning=FALSE, message=FALSE}
koty_ptaki$habitat
koty_ptaki$habitat_napis <- as.character(koty_ptaki$habitat)
koty_ptaki$habitat_napis
```

Funkcja `length()` dla każdego wektora sprawdza jego długość. Funkcja `nchar()` dla napisu sprawdza liczbę znaków w napisie.

```{r, warning=FALSE, message=FALSE}
# liczba napisów
length(koty_ptaki$habitat_napis)
# długość każdego napisu
nchar(koty_ptaki$habitat_napis)
```

---

# Wyszukiwanie napisu

Częstą operacją na napisach jest wyszukanie tych, które pasują do wzorca. Jeżeli chodzi nam o zgodność co do znaku, to wygodne będzie użycie funkcji `which()`. Jako wynik zwraca indeksy dla których określony warunek jest prawdziwy.

```{r, warning=FALSE, message=FALSE}
# które wartości wektora habitat_napis to 'Azja'
which(koty_ptaki$habitat_napis == "Azja")
# które wartości wektora habitat_napis to 'Azja' lub `Afryka`
which(koty_ptaki$habitat_napis %in% c("Azja", "Afryka"))
```

Często jednak, zamiast wymieniać wszystkie wartości, które chcemy wyszukać, wygodniejsze jest opisanie tych wartości przez pewien wzorzec. Do takiego wyszukiwania służy funkcja `grep()`. Testuje ona w którym z napisów wystepuje określony ciąg znaków, a jako wynik zwraca numery napisów z tym ciągiem.

Przykładowo, sprawdźmy które wiersze w kolumnie `habitat_napis` posiadają w nazwie znak `A`. Pierwszym argumentem funkcji `grep()` jest wzorzec, drugim wektor napisów. Możęmy te argumenty podać w innej kolejności, ale wtedy zmuszenie jesteśmy do podawania ich nazwy.
```{r, warning=FALSE, message=FALSE}
grep("A", koty_ptaki$habitat_napis)
# równoważnie
grep(koty_ptaki$habitat_napis, pattern="A")
```

Jeżeli zamiast indeksów, chcemy otrzymać wartości, ktróe zostały dopasowane, wtedy powinniśmy ustawić argument `value` na wartość TRUE.
 
```{r, warning=FALSE, message=FALSE}
grep("A", koty_ptaki$habitat_napis, value = TRUE)
```

Innym przydatnym argumentem funkcji `grep()` jest możliwość określenia, że wyszukiwanie ma być wykonane z pominięciem informacji o wielkości znaków. Służy do tego argument `ignore.case=TRUE`.

```{r, warning=FALSE, message=FALSE}
grep("A", koty_ptaki$habitat_napis, ignore.case = TRUE)
```

Określając wzorzec możemy wykorzystać wyrażenia regularne. Pozwalają one opisac pewną prawidłowość, którą chcemy wyszukać dane. Wyrażenia regularne są często stosowane aby sprawdzić czy napis jest na przykład mailem, numerem telefonu lub kodem pocztowym.

Więcej o wyrażeniach regularnych można przeczytac choćby na wikipedii http://pl.wikipedia.org/wiki/Wyra%C5%BCenie_regularne#Wyra.C5.BCenia_regularne_w_praktyce.

Poniższe wyrażenie, sprawdza czy początek napisu to litera A lub E.

```{r, warning=FALSE, message=FALSE}
grep("^[AE]", koty_ptaki$habitat_napis)
```

---

# Elementy napisu

Kolejną przydatną funkcją, do operowania na napisach jest `substr()`. Pozwala ona z napisu wyciąć fragment o określonej pozycji, drugim i trzecim argumentem są indeksy początku i końca napisu, który chcemy wyciąć. 

Przykładowo, w ten sposób możemy z dat wycinać informację o latach lub miesiącach. 

```{r, warning=FALSE, message=FALSE}
daty <- c("2014-01-01", "2015-03-15", "2010-12-01")
substr(daty, 1, 4)
substr(daty, 6, 7)
```

Innym sposobem wyłuskiwania elemtnu napisu jest podanie wzorca który rozdziela istotne elementy napisu, np. słowa. W poniższym przykładzie dwa zdania są rozbijane na wyrazy (a dokładniej rozbijane na fragmenty rozdzielane spacją). Wynikiem jest dwuelementowa lista wektorów. Wybieramy pierwszy wektor i odczytujemy z niego drugie słowo.

```{r, warning=FALSE, message=FALSE}
zdanie <- c( "W szczebrzeszynie chrząszcz brzmi w trzcinie", "Ząb zupa zębowa dąb zupa dębowa")
(podzielony <- strsplit(zdanie, " "))
slowa1 <- podzielony[[1]]
slowa1[2]
```

---

# Zadanie

+ Wyznacz ndeksy wierszy w zbiorze danych `koty_ptaki`, w których `gatunek` zawiera dużą lub małą literę `S`.

+ Wyznacz wszystkie wiersze, w których opisano jakiś gatunek sokoła.


---

# Wczytanie danych

```{r, warning=FALSE, message=FALSE}
library(SmarterPoland)
head(auta2012, 2)
```

Każdy wiersz tego zbioru danych opisuje jedną ofertę sprzedaży auta. Każda kolumna opisuje jedną cechę / właściwość tej oferty.

---

# Cechy napisowe
Funkcja `read.table()` wczytując tekst, domyślnie zamienia go na zmienną jakościową. 
To domyślne zachowanie można zmienić, ustawiając argument `stringsAsFactors=FALSE`, ale często konwersja na zmienną jakościową pozwala na przechowywanie danych w mneijszej ilości pamięci.

W pewnych sytuacjach, chcemy przetwarzać dane jak napisy, po to by na tych napisach wykonywać określone operacje na napisach. Takie np. jak wyszukiwanie podciągu w tekście. 

Aby to zrobić, musimy w pierwszej kolejności zamienić zmienna jakościową na zmienną napisową. Konwersję cechy z cechy jakościowej na cechę napisową można wykonać funkcją `as.character()`

```{r, warning=FALSE}
auta2012$Wyposazenie.dodatkowe.napis = as.character(auta2012$Wyposazenie.dodatkowe)
summary(auta2012$Wyposazenie.dodatkowe.napis)
```

---

O ile funkcja `as.character()` przekształca wartości na napisy, to funkcja `as.factor()` przekształca wartości na cechy jakościowe. Podobnie funkcja `as.numeric()` przekształca wartości na liczby. 

Należy być jednak ostrożnym przy tych konwersjach, przekształcając wartości jakościowe na liczby domyślnie R zamienia kolejne poziomy na kolejne liczby naturalne.

```{r, warning=FALSE}
x <- c("2", "4", "5.5")
(fx <- as.factor(x))
# liczby zgodnie z oczekiwniami 
as.numeric(x)
# uwaga! R nie wie że to są napisy, a zmienną jakościową zamienia na kolejne liczby całkowite
as.numeric(fx)
# zmienne jakościowe na liczby należałoby tak przekształcić
as.numeric(as.character(fx))
```


---

# Statystyki opisowe

Męskie imiona kończące się na 'a'

```{r, warning=FALSE}
library(dplyr)
imiona_warszawa %>%
  mutate(imie = as.character(imie)) %>%
  filter(plec == "M", substr(imie, nchar(imie), nchar(imie)) == "a") %>%
  group_by(imie) %>%
  summarise(liczba = sum(liczba))

```

Żeńskie imiona nie kończące się na 'a'

```{r, warning=FALSE}
imiona_warszawa %>%
  mutate(imie = as.character(imie)) %>%
  filter(plec == "K", substr(imie, nchar(imie), nchar(imie)) != "a") %>%
  group_by(imie) %>%
  summarise(liczba = sum(liczba)) %>%
  group_by() %>%
  arrange(desc(liczba))

```

---

# Statystyki opisowe

Jedną z interesujących operacji na napisach, jest sprawdzenie, czy zawierają one określony podciąg znaków. 
Taki test można wykonać funkcją `grepl()`, która jako wynik zwraca wartość logiczną określającą czy napis zawiera określony wzorzec czy nie.

```{r, warning=FALSE}
maKlimatyzacje = grepl(auta2012$Wyposazenie.dodatkowe.napis, pattern="klimatyzacja")
table(maKlimatyzacje)

auta2012$Wyposazenie.dodatkowe.napis = as.character(auta2012$Wyposazenie.dodatkowe)
bezwypadkowy = grepl(auta2012$Wyposazenie.dodatkowe.napis, pattern="bezwypadkowy")
table(bezwypadkowy)
```

**PCH: Albo używasz nazw parametrów, albo nie. Ludzie tu się dopiero uczą! Nie 
wiedzą czy trzeba podawać nazwy jak 'pattern' czy też nie! A zatem, jest to doskonałe
miejsce na dygresję i wprowadzenie na temat wywoływania funkcji, parametrów, itd.
W szczególności, że w przykładzie z `grepl()` parametr 'pattern' jest pierwszy,
a 'x' (u Ciebie pierwszy i bez nazwy) jest drugi.**

**PCH: Przed zadaniem drugim powinna się znaleźć informacja, że grepl przy domyślnych
ustawieniach robi 'partial matching'. Raz że to przydatna informacja, dwa że
oszczędzi ludziom 'ręcznego' wpisywania wszystkich kolorów jak 'zielony-metallic'
i dodawania wyników na kartce ')**

---

# Zadania:
+ Sprawdź ile samochodów ma zainstalowany autoalarm (oznaczony jako 'autoalarm')
+ Sprawdź ile samochodów ma lakier w metalicznym kolorze (oznaczony jako 'metallic')

# Odpowiedzi:
+ `r sum(grepl(auta2012$Wyposazenie.dodatkowe.napis, pattern="autoalarm"))`
+ `r sum(grepl(as.character(auta2012$Kolor), pattern="metallic"))`


stringi
Marek Gągolewski
http://smarterpoland.pl/SER/#SERII

Manual do operacji na napisach

http://gastonsanchez.com/Handling_and_Processing_Strings_in_R.pdf



  