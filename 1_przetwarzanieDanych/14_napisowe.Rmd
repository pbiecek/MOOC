---
title: "Cechy napisowe"
author: "pogRomcy danych"
date: "sezon 1 / odcinek 14 <br><br> <a href='http://biecek.pl/'>Przemysław Biecek @ Uniwersytet Warszawski</a><br><br><br>Naciśnij `A` by zamienić slajdy na ciągły tekst. <br> Naciśnij `T` by wyświetlić spis treści."
output:
  slidy_presentation:
    includes:
      in_header: ../tracking.html
    highlight: default
    css: ../style.css
    font_adjustment: 0
    footer: "pogRomcy danych / przetwarzanie / zmienne napisowe"

---


# O czym jest ten odcinek

Analizując dane spotkamy się z różnymi rodzajami zmiennych. Bardzo często są to napisy lub zmienne, które chcemy do napisów 
przekształcić (np. data, którą można przekształcić na napisy by wyłuskać rok i miesiąc).

W tym odcinku nauczymy się:

- jak przekształcać zmienne z napisów i na napisy,
- jakie podstawowe operacje można wykonywać na napisach,
- jak podsumowywać / opisywać napisy.

Do ilustracji tych zagadnień wykorzystamy dwa zbiory danych. Pierwszy, mały zbiór danych, to `koty_ptaki` a drugi, 
znacznie większy, to `auta2012`, oba dostępne w pakiecie `PogromcyDanych`.

---

# Co to znaczy: napisy

Osoby mające doświadczenie w pracy z takimi językami jak C++ czy Java są przyzwyczajone do podziału typów na znaki, 
napisy (łańcuchy znaków) i wektory napisów. W programie R nie ma tego podziału, są tylko wektory napisów. 

Wektor może być jednoelementowy i długość tego jednego elementu może wynosić jeden, ale wciąż to wektor napisów. 
Takie wektory oznaczane są klasą `character`.

```{r}
class("A")
```

Napisy spotkać można w różnych kontekstach. Najbardziej naturalnym jest taki, że w zbiorze danych były zebrane wypowiedzi. 
Np. pobierając dane z Twittera, jedną ze zmiennych opisujących pojedyncze ,,ćwierknięcie'' jest jego treść, czyli napis o długości do 140 znaków.

Napisy pojawiają się też, gdy wczytywane są dane ilościowe lub jakościowe, ale z jakiegoś powodu w procesie 
wczytywania dane te zinterpretowane zostały jako napisy (np. przez źle określone formatowanie). W takim przypadku napisy przekształcamy często 
na pożądany typ, np. ilościowy, jakościowy, datę itp.

```{r}
as.numeric("2012")     # konwersja na liczbę
as.factor(c("A", "B", "A", "A")) # konwersja na zmienną jakościową
as.Date("2012-01-01")  # konwersja na datę
```

---

# Wczytanie danych

Dane od których rozpoczniemy przykłady to `koty_ptaki` z pakietu `PogromcyDanych`. Aby te dane wczytać, 
wystarczy włączyć pakiet - instrukcja jak to zrobić znajduje się w odcinku 2.

Włączmy pakiet i użyjmy funkcji `head()`, by wyświetlić pierwsze sześć wierszy.

```{r, warning=FALSE, message=FALSE}
library(PogromcyDanych)
head(koty_ptaki)
```

Każdy wiersz opisuje jeden gatunek. Jak wiemy z poprzedniego odcinka, zmienne `gatunek`, `habitat` i `druzyna` to 
zmienne jakościowe. Przekształcimy je na napisy, aby zademonstrować podstawowe operacje na napisach.

---

# Konwersja na napis

Wybierzmy kolumnę `habitat`. W zbiorze danych `koty_ptaki` jest to zmienna jakościowa. 
Użyjemy funkcji `as.character()` by przekształcić ją na napisy. Otrzymane napisy zapiszemy w kolumnie `habitat_napis`.

```{r, warning=FALSE, message=FALSE}
koty_ptaki$habitat
koty_ptaki$habitat_napis <- as.character(koty_ptaki$habitat)
koty_ptaki$habitat_napis
```

Funkcja `length()` dla każdego wektora sprawdza jego długość (liczbę napisów). Funkcja `nchar()` dla napisu sprawdza liczbę znaków w każdym napisie w wektorze (długość każdego napisu).

```{r, warning=FALSE, message=FALSE}
length(koty_ptaki$habitat_napis)
nchar(koty_ptaki$habitat_napis)
```

---

# Wyszukiwanie napisu

Częstą operacją na napisach jest wyszukanie tych, które pasują do wzorca. Jeżeli chodzi nam o zgodność co do znaku, 
to wygodne będzie użycie funkcji `which()`. Jako wynik zwraca indeksy, dla których określony warunek jest prawdziwy.

Które wartości wektora habitat_napis to `Azja`?

```{r, warning=FALSE, message=FALSE}
which(koty_ptaki$habitat_napis == "Azja")
```
Które wartości wektora habitat_napis to `Azja` lub `Afryka`?
```{r, warning=FALSE, message=FALSE}
which(koty_ptaki$habitat_napis %in% c("Azja", "Afryka"))
```

Często jednak, zamiast wymieniać wszystkie wartości, które chcemy wyszukać, wygodniejsze jest opisanie tych wartości przez pewien wzorzec. 
Do takiego wyszukiwania służy funkcja `grep()`. Testuje ona, w którym z napisów występuje określony ciąg znaków, a jako wynik zwraca numery 
napisów z tym ciągiem.

Sprawdźmy, które wiersze w kolumnie `habitat_napis` posiadają w nazwie znak `A`. Pierwszym argumentem funkcji `grep()` jest wzorzec, 
drugim wektor napisów. Możemy te argumenty podać w innej kolejności, ale wtedy zmuszeni jesteśmy do podawania ich nazwy.

```{r, warning=FALSE, message=FALSE}
grep("A", koty_ptaki$habitat_napis)
```
Równoważnie
```{r, warning=FALSE, message=FALSE}
grep(koty_ptaki$habitat_napis, pattern="A")
```

---

# Wyszukiwanie napisu

Jeżeli zamiast indeksów chcemy otrzymać wartości, które zostały dopasowane, wtedy powinniśmy ustawić argument `value` na wartość TRUE.
 
```{r, warning=FALSE, message=FALSE}
grep("A", koty_ptaki$habitat_napis, value = TRUE)
```

Innym przydatnym argumentem funkcji `grep()` jest możliwość określenia, że wyszukiwanie ma być wykonane z pominięciem informacji o wielkości znaków. 
Służy do tego argument `ignore.case=TRUE`.

```{r, warning=FALSE, message=FALSE}
grep("A", koty_ptaki$habitat_napis, ignore.case = TRUE)
```

Określając wzorzec możemy wykorzystać wyrażenia regularne. Pozwalają one opisać pewną prawidłowość, którą chcemy wyszukać w danych. 
Wyrażenia regularne są często stosowane, aby sprawdzić czy napis jest na przykład mailem, numerem telefonu lub kodem pocztowym.

Więcej o wyrażeniach regularnych można przeczytać choćby na Wikipedii http://pl.wikipedia.org/wiki/Wyra%C5%BCenie_regularne#Wyra.C5.BCenia_regularne_w_praktyce.

Poniższe wyrażenie, sprawdza czy początek napisu to litera A lub E.

```{r, warning=FALSE, message=FALSE}
grep("^[AE]", koty_ptaki$habitat_napis)
```

---

# Fragmentu napisów

Kolejną przydatną funkcją do operowania na napisach jest `substr()`. Pozwala ona z napisu wyciąć fragment o określonej pozycji, 
drugim i trzecim argumentem są indeksy początku i końca napisu, który chcemy wyciąć. 

Przykładowo, w ten sposób możemy z dat wycinać informację o latach lub miesiącach. 

```{r, warning=FALSE, message=FALSE}
daty <- c("2014-01-01", "2015-03-15", "2010-12-01")
substr(daty, 1, 4)
substr(daty, 6, 7)
```

Innym sposobem wyłuskiwania elementu napisu jest podanie wzorca który rozdziela istotne elementy napisu, np. słowa. 
W poniższym przykładzie dwa zdania są rozbijane na wyrazy (a dokładniej rozbijane na fragmenty rozdzielane spacją). 
Wynikiem jest dwuelementowa lista wektorów. Wybieramy pierwszy wektor i odczytujemy z niego drugie słowo.

```{r, warning=FALSE, message=FALSE}
zdanie <- c( "W Szczebrzeszynie chrząszcz brzmi w trzcinie", "Ząb zupa zębowa dąb zupa dębowa")
(podzielony <- strsplit(zdanie, " "))
slowa1 <- podzielony[[1]]
slowa1[2]
```

---

# Zadanie

+ Wyznacz indeksy wierszy w zbiorze danych `koty_ptaki`, w których `gatunek` zawiera dużą lub małą literę `S`.

+ Wyznacz wszystkie wiersze, w których opisano jakiś gatunek sokoła.


---

# Wczytanie danych

Zbiór danych `koty_ptaki` składa się z 13 wierszy. Można cały ten zbiór danych wyświetlić na ekranie. 
Nie zawsze potrzebujemy więc specjalnych statystyk opisowych, by zrozumieć co się dzieje w takich małych zbiorach danych.

Dlatego dalsze ćwiczenia z napisami przeprowadzimy na znacznie większym zbiorze danych `auta2012`, z ponad 200 tysiącami wartości, 
który również znajduje się w pakiecie `PogromcyDanych`.

Opis tego zbioru danych znaleźć można w odcinku http://pogromcydanych.icm.edu.pl/materials/1_przetwarzanie/0_dane.html

Wczytajmy ten zbiór danych i przyjrzyjmy się dwóm pierwszym wierszom. 


```{r, warning=FALSE, message=FALSE}
library(PogromcyDanych)
head(auta2012, 2)
```

Dwie kolumny `Wyposazenie.dodatkowe` oraz `Kolor` będą nas szczególnie interesowały, jeżeli chodzi o analizę napisów.

---

# Napisy

Wczytując dane do programu R większość funkcji, domyślnie zamienia napisy na zmienne jakościowe.
To zagadnienie było szerzej omawiane w odcinku 5. 

W sytuacjach, gdy chcemy przetwarzać napisy, musimy zmienne jakościowe przekształcić na napisy używając funkcji `as.character()`.

```{r, warning=FALSE}
auta2012$Kolor_napis <- as.character(auta2012$Kolor)
auta2012$Wyposazenie.dodatkowe_napis <- as.character(auta2012$Wyposazenie.dodatkowe)
```

---

# Napisy

W analizie danych często stoimy przed potrzebą stworzenia nowych cech na bazie starych. 
Przykładowo, jeżeli spojrzymy na wektor kolorów samochodów, możemy uznać że interesującą cechą byłoby określenie, czy lakier jest koloru metalicznego czy nie.

```{r, warning=FALSE}
sort(table(auta2012$Kolor_napis))
```

Można zrobić to na kilka sposobów. Najłatwiejszym jest użycie funkcji `grepl()`, o takich samych parametrach jak funkcja `grep()` z 
tym wyjątkiem, że wynikiem jest wektor wartości logicznych TRUE/FALSE określający czy dany wzorzec został odnaleziony czy nie w napisach.

```{r, warning=FALSE}
auta2012$czy_metallic <- grepl("metallic", auta2012$Kolor_napis)
table(auta2012$czy_metallic)
```

---

# Napisy

W podobny sposób, można stworzyć dodatkowe kolumny określające, czy auto ma na wyposażeniu klimatyzację lub czy szyby są przyciemniane.

W drugim przykładzie warto zwrócić uwagę na to, że argumenty są podane w kolejności innej niż domyślna. 
Dlatego argument ze wzorcem musiał mieć dodatkowo wskazaną nazwę `pattern=`.

```{r, warning=FALSE}
auta2012$maKlimatyzacje <- grepl("klimatyzacja", auta2012$Wyposazenie.dodatkowe_napis)
table(auta2012$maKlimatyzacje)
```

Około 20% oferowanych aut ma przyciemniane szyby.
```{r, warning=FALSE}
auta2012$szyby <- grepl(x=auta2012$Wyposazenie.dodatkowe_napis, 
                               pattern="przyciemniane szyby")
table(auta2012$szyby)
```

---

# Sklejanie napisów 

Operacją przeciwną do dzielenia napisu na fragmenty jest sklejanie kilku napisów w jeden.

Do tego celu można wykorzystać funkcję `paste()` lub `paste0()`.

Przedstawmy jej działanie na prostym przykładzie. Będziemy sklejać wektor dziesięciu liter, dziesięciu cyfr i jednego napisu.

Funkcje w programie R, które operują na wektorach (większość), jeżeli mają dwa argumenty o różnej długości to krótszy argument 
jest zwielokrotniony tylekrotnie, aby dorównał długością dłuższemu (tzw. recycling rule). Z tego powodu trzeci argument - pojedyncza 
kropka - będzie zwielokrotniona i sklejona z każdym z dziesięciu elementów wektorów `litery` i `cyfry`.

```{r, warning=FALSE}
litery <- LETTERS[1:10]
cyfry  <- 1:10
```

Funkcja `paste()` skleja wartości rozdzielając je separatorem, którym domyślnie jest spacja. Znak separatora 
można zmienić wskazując argument `sep`. Funkcja `paste0()` tym różni się od funkcji `paste()`, że separator jest pustym napisem.

```{r, warning=FALSE}
paste(litery, cyfry, ".")
paste(litery, cyfry, ".", sep="-")
paste0(litery, cyfry, ".")
```

---

# Sklejanie napisów 

Przedstawmy funkcję do sklejania napisów na przykładzie sklejania nazwy marki i modelu dla auta.

W pierwszej linii skleimy oba wektory, używając za separator `': '`. Następnie zliczymy ile było wystąpień takich par i uporządkujemy je w kolejności malejącej.

Wyświetlamy 25 najczęstszych modeli.

```{r, warning=FALSE}
auta2012$MarkaModel   <- paste(auta2012$Marka, auta2012$Model, sep=": ")

statystykiMarkiModelu <- sort(table(auta2012$MarkaModel), decreasing = TRUE)

head(statystykiMarkiModelu, 25)
```

---

# Imiona dzieci

W pakiecie `PogromcyDanych` jest również dostępny zbiór danych `imiona_warszawa` ze statystykami popularności imion nadawanych noworodkom w Warszawie w różnych okresach czasu.

Używając tego zbioru danych, możemy przetestować regułę mówiącą, że imię dziewczynki kończy się na literkę 'a', a chłopca nie. Jakiś czas temu za jedyny wyjątek podawano męskie 
imię Bonawentura. Czy to się zmieniło?

Wybierzmy do analizy tylko imiona chłopców (indeksowanie `imiona_warszawa$plec == "M"`). Ponieważ każde imię powtarza się dla każdego miesiąca, to funkcją `unique()` usuniemy wszystkie duplikaty. 

Następnie funkcją `grep()` wybierzemy wszystkie imiona, których ostatnia litera to `a` (wyrażenie regularne `a$`) i wyświetlimy te imiona. Bonawentury nie widać ale są inne imiona.

```{r, warning=FALSE}
imiona_chlopcow <- imiona_warszawa[imiona_warszawa$plec == "M", ]
same_imiona     <- unique(imiona_chlopcow$imie)
grep("a$", same_imiona, value = TRUE)
```

Podobne operacje powtórzymy dla dziewcząt. Tym razem do wyrażenia regularnego podamy wzorzec wszystkie litery poza a, czyli `[^a]$`. Takich dziewczęcych imion jest wiele.

```{r, warning=FALSE}
imiona_dziewczat <- imiona_warszawa[imiona_warszawa$plec == "K", ]
same_imiona      <- unique(imiona_dziewczat$imie)
grep("[^a]$", same_imiona, value = TRUE)
```


---

# Liczby, cechy jakościowe i napisy

Funkcja `as.character()` może być przydatna jeszcze w jednej sytuacji, tzn. gdy zmienną jakościową chcemy przekształcić na zmienną liczbową. Nie powinniśmy tego zrobić bezpośrednio, 
ale poprzez funkcję `as.character()`.

Pokażmy ten problem na przykładzie. Zamienimy zmienne na zmienne jakościowe funkcją `as.factor()` a następnie na liczby funkcją `as.numeric()`. Okazuje się jednak, że wynik nie jest zgodny z oczekiwaniami.

```{r, warning=FALSE}
x <- c(2, 4, 5.5)
(fx <- as.factor(x))
```
Uwaga! Program R nie wie że to są napisy, a zmienną jakościową zamienia na kolejne liczby całkowite.
```{r, warning=FALSE}
as.numeric(fx)
```

Zmienne jakościowe przez funkcję `as.numeric()` zamieniane są na kolejne liczby całkowite. Jeżeli chcemy odzyskać liczby, które są treścią czynników, to musimy je wpierw zamienić na napisy, funkcją `as.character()`.

```{r, warning=FALSE}
as.numeric(as.character(fx))
```

Alternatywnie, można wykorzystać odrobinę wydajniejszy i również odrobinę mniej czytelny sposób zamiany zmiennych jakościowych na liczby.
```{r, warning=FALSE}
as.numeric(levels(fx))[fx] 
```

---

# Zadania:

+ Sprawdź ile samochodów ma zainstalowany autoalarm (oznaczony jako 'autoalarm')

+ Sprawdź ile samochodów ma lakier w metalicznym kolorze (oznaczony jako 'metallic')

Przykładowe odpowiedzi znajdują się na stronie http://pogromcydanych.icm.edu.pl/materials/1_przetwarzanie/9_zadania.html

---

# Gdzie szukać dodatkowych informacji

Jedynie zarysowaliśmy temat analizy napisów. 

Przy przetwarzaniu większych korpusów tekstu, pojawia się wiele interesujących tematów, takich jak analiza znaczenia, analiza częstościowa, tagowanie itp.

+ Więcej o podstawowych operacjach do pracy z napisami przeczytać można w rozdziale 2.1 ,,Przewodnika po pakiecie R'' GiS 2013. Rozdział ten jest dostępny bezpłatnie na stronie http://biecek.pl/R/

+ Gdy pracujemy z dużymi korpusami, możemy przyśpieszyć obliczenia stosując pakiet `stringr`. Bardzo dobrze przygotowany materiał opisujący funkcje tego pakietu jest udostępniony przez Gastona Sancheza na stronie http://gastonsanchez.com/Handling_and_Processing_Strings_in_R.pdf.

+ Gdy pracujemy z napisami bardzo użyteczne są wyrażenia i metaznaki. Krótkie ale treściwe omówienie wyrażań regularnych, opracowane przez S. Jonesa znajduje się w dokumencie ,,String manipulation in R'' http://www3.nd.edu/~sjones20/JonesUND/BioStats_files/RstringManipulation_2-6-13.pdf.

+ Interesującą alternatywą wspierająca bardziej egzotyczne języki (bardziej niż angielski) jest pakiet `stringi`. Można o nim posłuchać na wystąpieniu Marka Gągolewskiego z II Spotkania Entuzjastów R. Materiał wideo dostępny jest na stronie http://smarterpoland.pl/SER/#SERII

