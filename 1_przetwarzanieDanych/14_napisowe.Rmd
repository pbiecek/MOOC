---
title: "Cechy napisowe"
author: "pogRomcy danych"
date: "sezon 1 / odcinek 14 <br><br> Wszelkie prawa zastrzeżone.<br> Wykorzystanie możliwe wyłącznie za zgodą autora.  <br><br><br><br>Naciśnij `A` by zamienić slajdy na ciągły tekst. <br> Naciśnij `T` by wyświetlić spis treści."
output:
  slidy_presentation:
    includes:
      in_header: ../tracking.html
    highlight: default
    css: ../style.css
    font_adjustment: 0
    footer: "pogRomcy danych / przetwarzanie / zmienne napisowe"

---


# O czym jest ten odcinek

Analizując dane spotkamy się z różnymi rodzajami zmiennych. 
Bardzo często są to napisy lub zmienne, które chcemy do napisów przekształcić (np. data, którą można przekształcić do napisy by wyłuskać roki miesiąc).

W tym odcinku nauczymy się

- Jak przekształcać zmienne na i z napisów?
- Jakie podstawowe operacje można wykonywać na napisach?
- Jak podsumowywać / opisywać napisy?

Do ilustracji tych zagadnień wykorzystamy dwa zbiory danych. Pierwszy, mały zbiór danych, to `koty_ptaki` a drugi, znacznie większy, to `auta2012`, oba dostępne w pakiecie `SmarterPoland`.

---

# Co to znaczy: napisy

Osoby mające doświadceznie w pracy z takimi językami jak C++ czy Java są przyzwyczajone do rozdizały typów na znaki, napisy (łańcuchy znaków) i wektory napisów. W programie R nie ma tego podziału, są tylko wektory napisów. 

Wektor może być jednoelementowy i długość tego jednego elementu może wynosić jeden, ale wciąż to wektor napisów. Takie wektory oznaczane są klasą `character`.

```{r}
class("A")
```

Napisy spotkać można w różnych kontekstach. Najbardziej naturalnym jest taki, że w zbiorze danych były zebrae wypowiedzi. Np. pobierając dane z Twittera, jedną ze zmiennych opisujących pojedyńcze ćwierknięcie jest treść tweetu czyli napis o długości do 140 znaków.

Napisy pojawiają się też, gdy wczytywane są dane ilościowe lub jakościowe, ale z jakiegoś powodu w procesie wczytywania dane te wczytały się jako napisy (np. przez źle określone formatowanie). W takim przypadku, często napisy przekształcamy na porządany typ, np. ilościowy, jakościowy, datę itp.

```{r}
as.numeric("2012")     # konwersja na liczbę
as.factor(c("A", "B", "A", "A")) # konwersja na zmienną jakościową
as.Date("2012-01-01")  # konwersja na datę
```

---

# Wczytanie danych

Dane od których rozpoczniemy przykłady to `koty_ptaki` z pakietu `SmarterPoland`. Aby te dane wczytać, wystarczy włączyć pakiet, instrukcja jak to zrobić znajduje się w odcinku 2.

Włączmy pakiet i użyjmy funkcji `head()` by wyświetlić pierwsze sześć wierszy.

```{r, warning=FALSE, message=FALSE}
library(SmarterPoland)
head(koty_ptaki)
```

Każdy wiersz opisuje jeden gatunek. Jak wiemy z poprzedniego odcinka, zmienna gatunek, habitat i drużyna to zmienne jakościowe. Przekształcimy je na napisy aby zademonstrować podstawowe operacje na napisach.

---






---

# Wczytanie danych

```{r, warning=FALSE, message=FALSE}
library(SmarterPoland)
head(auta2012, 2)
```

Każdy wiersz tego zbioru danych opisuje jedną ofertę sprzedaży auta. Każda kolumna opisuje jedną cechę / właściwość tej oferty.

---

# Cechy napisowe
Funkcja `read.table()` wczytując tekst, domyślnie zamienia go na zmienną jakościową. 
To domyślne zachowanie można zmienić, ustawiając argument `stringsAsFactors=FALSE`, ale często konwersja na zmienną jakościową pozwala na przechowywanie danych w mneijszej ilości pamięci.

W pewnych sytuacjach, chcemy przetwarzać dane jak napisy, po to by na tych napisach wykonywać określone operacje na napisach. Takie np. jak wyszukiwanie podciągu w tekście. 

Aby to zrobić, musimy w pierwszej kolejności zamienić zmienna jakościową na zmienną napisową. Konwersję cechy z cechy jakościowej na cechę napisową można wykonać funkcją `as.character()`

```{r, warning=FALSE}
auta2012$Wyposazenie.dodatkowe.napis = as.character(auta2012$Wyposazenie.dodatkowe)
summary(auta2012$Wyposazenie.dodatkowe.napis)
```

---

O ile funkcja `as.character()` przekształca wartości na napisy, to funkcja `as.factor()` przekształca wartości na cechy jakościowe. Podobnie funkcja `as.numeric()` przekształca wartości na liczby. 

Należy być jednak ostrożnym przy tych konwersjach, przekształcając wartości jakościowe na liczby domyślnie R zamienia kolejne poziomy na kolejne liczby naturalne.

```{r, warning=FALSE}
x <- c("2", "4", "5.5")
(fx <- as.factor(x))
# liczby zgodnie z oczekiwniami 
as.numeric(x)
# uwaga! R nie wie że to są napisy, a zmienną jakościową zamienia na kolejne liczby całkowite
as.numeric(fx)
# zmienne jakościowe na liczby należałoby tak przekształcić
as.numeric(as.character(fx))
```


---

# Statystyki opisowe

Męskie imiona kończące się na 'a'

```{r, warning=FALSE}
library(dplyr)
imiona_warszawa %>%
  mutate(imie = as.character(imie)) %>%
  filter(plec == "M", substr(imie, nchar(imie), nchar(imie)) == "a") %>%
  group_by(imie) %>%
  summarise(liczba = sum(liczba))

```

Żeńskie imiona nie kończące się na 'a'

```{r, warning=FALSE}
imiona_warszawa %>%
  mutate(imie = as.character(imie)) %>%
  filter(plec == "K", substr(imie, nchar(imie), nchar(imie)) != "a") %>%
  group_by(imie) %>%
  summarise(liczba = sum(liczba)) %>%
  group_by() %>%
  arrange(desc(liczba))

```

---

# Statystyki opisowe

Jedną z interesujących operacji na napisach, jest sprawdzenie, czy zawierają one określony podciąg znaków. 
Taki test można wykonać funkcją `grepl()`, która jako wynik zwraca wartość logiczną określającą czy napis zawiera określony wzorzec czy nie.

```{r, warning=FALSE}
maKlimatyzacje = grepl(auta2012$Wyposazenie.dodatkowe.napis, pattern="klimatyzacja")
table(maKlimatyzacje)

auta2012$Wyposazenie.dodatkowe.napis = as.character(auta2012$Wyposazenie.dodatkowe)
bezwypadkowy = grepl(auta2012$Wyposazenie.dodatkowe.napis, pattern="bezwypadkowy")
table(bezwypadkowy)
```

**PCH: Albo używasz nazw parametrów, albo nie. Ludzie tu się dopiero uczą! Nie 
wiedzą czy trzeba podawać nazwy jak 'pattern' czy też nie! A zatem, jest to doskonałe
miejsce na dygresję i wprowadzenie na temat wywoływania funkcji, parametrów, itd.
W szczególności, że w przykładzie z `grepl()` parametr 'pattern' jest pierwszy,
a 'x' (u Ciebie pierwszy i bez nazwy) jest drugi.**

**PCH: Przed zadaniem drugim powinna się znaleźć informacja, że grepl przy domyślnych
ustawieniach robi 'partial matching'. Raz że to przydatna informacja, dwa że
oszczędzi ludziom 'ręcznego' wpisywania wszystkich kolorów jak 'zielony-metallic'
i dodawania wyników na kartce ')**

---

# Zadania:
+ Sprawdź ile samochodów ma zainstalowany autoalarm (oznaczony jako 'autoalarm')
+ Sprawdź ile samochodów ma lakier w metalicznym kolorze (oznaczony jako 'metallic')

# Odpowiedzi:
+ `r sum(grepl(auta2012$Wyposazenie.dodatkowe.napis, pattern="autoalarm"))`
+ `r sum(grepl(as.character(auta2012$Kolor), pattern="metallic"))`


stringi
Marek Gągolewski
http://smarterpoland.pl/SER/#SERII

Manual do operacji na napisach

http://gastonsanchez.com/Handling_and_Processing_Strings_in_R.pdf



  