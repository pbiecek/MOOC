---
title: "Qualitative variables"
author: "Data CruncheRs"
date: season 1 / episode 12 <br><br> All rights reserved.<br> Using without permission is prohibited <br><br><br><br>Press `A` to change slides into text <br> Press `T` to display table of contents.
output:
  beamer_presentation:
    highlight: default
  slidy_presentation:
    css: ../style.css
    font_adjustment: 0
    footer: Data CruncheRs / data processing / qualitative variables
    highlight: default
    includes:
      in_header: ../tracking.html
---

# What is this episode about?

When you analyze data you will come across many types of variables. Very often you will deal with qualitative values and in some cases you will need to transform a quantitative variable into a qualitative variable. 

In this episode you will learn:

- Which variables/ characteristics are referred to as qualitative characteristics?
-	What basic operations can be performed on qualitative characteristics? 
-	How to summarize/ describe qualitative characteristics?

We will use two data sets to illustrate these issues. The first set, `koty_ptaki` is quite small, while the other one, `auta2012` is a much more extensive data set. Both data sets are available in the package PogromcyDanych. 


---

# What does it mean: a qualitative variable

Qualitative variables are categorical variables - they specify groups to which the data belongs. For that reason they are also called  *grouping variables*. 
Another name frequently used by programmers is a *factor variable* (zmienna czynnikowa).

_As this type of variable is referred to as *factor* in R, in Polish we use a loanword: "zmienna faktor"_

When we define a qualitative variable we should indicate what groups we are referring to. Examples of qualitative variables are 
e.g. education (groups: primary, secondary, higher education), gender (groups: male, female), country of residence (groups: Poland,...).

A qualitative variable can be expressed in numbers, yet unless these numbers stand for amount of size, such a variable is in reality a qualitative variable.
For example, the first two numbers of a postal code may be a qualitative variable, while a school grade may be treated as a qualitative variable (or a quantitative variable depending on the context). 
The same concerns the number of car doors - if we want to use this characteristic to divide cars into two groups of two-door and three-door models, then this variable is treated a s a qualitative variable. 

Although qualitative variables can greatly differ as far as number and type of groups are concerned, there are several operations which can be performed on all of them. Let us see what are these operations. 



---

# Loading data

Our first examples will be based on the data set `koty_ptaki` from the package `PogromcyDanych`. In order to load this data you only need to activate the package - the instructions can be found in the episode 2. 

Let us activate the package and use the function `head()` to display the first six rows. Which of the displayed variables are qualitative variables? 


```{r, warning=FALSE, message=FALSE}
library(PogromcyDanych)
head(koty_ptaki)
```

Each row describes one species. In this case all non-numerical variables are qualitative variables, that is, *gatunek*, *habitat* and *druzyna* (species, habitat and group). 

---

# Qualitative variables

Let us look at two variables -  *gatunek* and *druzyna*.

```{r}
koty_ptaki$gatunek
koty_ptaki$druzyna
```


When we display these variables, we can also see a set of all the potential values. This set is usually called levels of the qualitative variable or a dictionary of the variable.

There are two basic operations which we can perform on qualitative variables. We can read levels of the variable (with the function `levels()`) and we can  determine the number of individual levels (with the function `table()`). 

We can check whether a given variable is qualitative or quantitative using the function `class()`.
If as a result we receive the word `factor`, we are dealing with a qualitative variable. 
f we get the word `integer` or `numeric`, we are dealing with a quantitative variable. 


```{r}
class(koty_ptaki$druzyna)
class(koty_ptaki$predkosc)
class(koty_ptaki$dlugosc)
```

---

# Qualitative variables

When we apply the two functions to two random variables from the data set `koty_ptaki` we receive the following results. 

Result of the function `levels()` is a vector of words - levels of the qualitative variable. 


```{r}
levels(koty_ptaki$gatunek)
levels(koty_ptaki$druzyna)
```

Result of the function `table()` is a vector of quantity of each factor. 

```{r}
table(koty_ptaki$gatunek)
table(koty_ptaki$druzyna)
```


Both variables differ in many aspects. There are only two possible values for *druzyna* and thirteen for *gatunek* (each row is a different value).
---

# Loading data

The data set `koty_ptaki` consists of 13 rows. 
All of them can be displayed on the computer screen. 
For such small sets we do not need special descriptive statistics to get the gist of their content.  

For this reason from now on we will practice working with qualitative variables on a much bigger data set containing over 200 thousand values called `auta_2012`, which is also available in the package `PogromcyDanych`.

You can find a description of this data set in the episode https://rawgit.com/pbiecek/MOOC/master/0_dane/0_dane.html

Let us load this set and look at its first two rows. 


```{r, warning=FALSE, message=FALSE}
library(PogromcyDanych)
head(auta2012, 2)
```

Which of the variables are qualitative variables?

---

# Descriptive statistics

Now we will focus on characteristics such as `Waluta` or `Marka`. These characteristics are expressed by values from a finite list of possible values.
Potential values of the characteristic `Waluta` are `levels(auta2012$Waluta)= CHF, CZK, EEK, EUR, GBP, HUF, PLN, USD`. 

We can perform several operations on qualitative variables. One of them is displaying the list of possible values. 
That list is often called a dictionary (list of potential values).

You can display the list of possible values for a qualitative variable using the function `levels()`.  



```{r, warning=FALSE}
levels(auta2012$Waluta)
```


Frequency distribution table is frequently used to describe qualitative variables. It displays number of occurrences of each value from the dictionary. 
You can draw the frequency distribution table with the function `table()` or `summary()`.
If there are gaps in the qualitative variable, the function `summary()` will also specify their number. 

```{r, warning=FALSE}
table(auta2012$Waluta)
summary(auta2012$Waluta)
```

---


# Exercises

+  How many variables from the data set `auta2012` are qualitative variables?

+ The variable `liczba.drzwi` takes values 2/3 and 4/5. It is treated as a qualitative variable. Yet we can also assume that liczna.drzwi is a quantitative variable because it specifies number of doors in a car. How can you explain that duality?

You can find sample answers at https://rawgit.com/pbiecek/MOOC/master/0_dane/9_zadania.html

---

# Percentages

In some cases it is much more convenient to use a table with percentage values rather than a frequency distribution table.

But how can we calculate these percentage values?

It can be done in several ways. The function `prop.table()` divides the values form the frequency distribution table by the sum of all the occurrences - it transforms quantities into fractions. 
Now let us attribute the result of the function `table()` to some variable, e.g. variable called `Waluta` (we can choose any name but afterwards we have to use it consistently).
Then we transform our newly created frequency distribution table into fractions.

In the following example we will put the command in brackets so that its result is also displayed. If there were no brackets, the result of the function `table()` would not be displayed, only attributed to the variable `Waluta`. 


```{r, warning=FALSE}
(waluty <- table(auta2012$Waluta))
prop.table(waluty)
```

---

# Percentages

The function `prop.table()` determines fractions which unfortunately are not really readable for humans.
It would be easier for us to receive results as percentages. Not any percentages, but nicely formatted percentages e.g. displayed to one decimal place.

If you want to change fractions into percentages, you only need to multiply them by 100. In order to display the results to one decimal place you need to use the function `round()` which rounds the numbers down to specified decimal place. 


```{r, warning=FALSE}
waluty <- table(auta2012$Waluta)
(frakcje <- prop.table(waluty))
(procenty <- 100*frakcje)
round(procenty, digits = 1)
```

All the operations presented above work for individual values (called scalars) as well as for vectors. 
For example, the function `100*frakcje` multiplies the number 100 by each element of the vector `frakcje`.
The result of that operation is a factor. Not every programming language allows for such mixed operations multiplying vectors by  scalars. 

---

# Ordered percentages

Now we have the percentage values. It is good to increase readability of this form of presentation by arranging the values in an ascending or descending order. 

Even if we deal with only eight numbers, we may have problems with identifying the biggest number when these numbers have got many digits. 

You may use the function `sort()` to order the numbers. When you also add the argument `decreasing = TRUE`, you will order the values in a descending order. 


```{r, warning=FALSE}
roundedPercentages <- round(procenty,1)
sort(roundedPercentages)
sort(roundedPercentages, decreasing = TRUE)
```

---

# Sorted percentages

Values in the vector can be sorted in many other ways.
The function `order()` is more complex but it will allows us to discuss more advanced examples of indexing.

The result of the function order() are indices of elements in  a vector listed in an ascending order. You can find more information about this function in the episode 7. 

```{r, warning=FALSE}
order(roundedPercentages)
```

If we read the vector `roundedPercentages` in the following order: first element, third, fifth, sixth, eighth, fourth, second and seventh, we will get an ordered sequence. 

We can use the result of the function to index the original data set. In this way we can sort the whole vector. 


```{r, warning=FALSE}
orderOfSorted <- order(roundedPercentages)
roundedPercentages[orderOfSorted]
```

But how can we check what are the positions of the three smallest values?

```{r, warning=FALSE}
orderOfSorted[1:3]
```

---

# Exercises

+ The characteristic `Marka` defines the make of the car. Check which make is the most popular one.

+	The characteristic `Rodzaj.paliwa` defines the type of fuel used by the car. Is it petrol, diesel oil or gas? Check what percentage of cars runs on petrol. 

You can find sample answers at https://rawgit.com/pbiecek/MOOC/master/0_dane/9_zadania.


---

# Graphic descriptive statistics

Frequency distribution tables are easy to interpret. Just like in other cases, however, graphic presentation of numbers allows for even easier comprehension of the content of data.
All in all, it is fairly easy to make a mistake concerning number of digits in a number in a traditional table. On a diagram such values literally hit us in the eyes.

Frequency distribution tables are usually presented in the form of bar charts. They can be created e.g. with the function `barplot()`. 


```{r, warning=FALSE, fig.width=5, fig.height=5}
(waluty <- table(auta2012$Waluta))
barplot(waluty)
```

---

# Graphic descriptive statistics

If you want the bars to be oriented horizontally, you need to add the argument `horiz = TRUE` to the function `barplot()`. 

The values are listed in alphabetical order by default but this arrangement does not always make sense. In this case it is much more reasonable to sort the data in an descending order. You can do that using the function `sort()`.

Use the argument `las=1` to ensure that labels are oriented horizontally. 


```{r, warning=FALSE, fig.width=5, fig.height=5}
sortedCurrency<- sort(waluty)
barplot(sortedCurrency, horiz = TRUE, las=1)
```

---

Exercises

+ Create a graphic presentation of the frequency distribution table for the variable `Kraj.pochodzenia`. Try out the horizontal and vertical versions of the diagram. Add the argument `las=1` in order to change the direction of the labels on the axes.

You can find sample answers at https://rawgit.com/pbiecek/MOOC/master/0_dane/9_zadania.html

---

# Strings or factors? 

Qualitative variables (factors) resemble string variables on the surface. Underneath, however, their representation is completely different.
Factors are not saved as strings but as pairs number vector-dictionary, which specify which string corresponds to which number. In this way you can use less memory to save big data sets. 

We also usually perform different operations on strings than on qualitative variables although it may happen that we deliberately try to read some data as strings. 
When we load data from a text file with strings, they are treated as factors by default. 

In the example below variables such as `gatunek` and `habitat` are loaded as `factor`-type variables. 
The side effect is the manner in which the results are displayed by e.g. the variable `cat()`.
This function will display on the screen numbers, not strings, for a qualitative variable

 

```{r, warning=FALSE, fig.height=5, fig.width=5}
koty_ptaki <- read.table("http://biecek.pl/MOOC/dane/koty_ptaki.csv", 
          sep=";", dec=",", header=TRUE)
str(koty_ptaki)
class(koty_ptaki$gatunek)
cat(koty_ptaki$gatunek)
```

---

# Strings or factors?

The function `read.table()` has got an argument `stringsAsFactors` which specifies how the tables with characters should be displayed.
When we specify the argument `stringsAsFactors=FALSE` we force the program to load data as string variables. 
They will occupy more space but the process of loading will take less time. 

Notice the new version of the result of the functions `str()` and `cat()`. 



```{r, warning=FALSE, fig.height=5, fig.width=5}
koty_ptaki <- read.table("http://biecek.pl/MOOC/dane/koty_ptaki.csv", 
          sep=";", dec=",", header=TRUE, stringsAsFactors=FALSE)
str(koty_ptaki)
class(koty_ptaki$gatunek)
cat(koty_ptaki$gatunek)
```

This time the column `gatunek` was loaded as a string vector. 

---

# Strings or factors?

Factor variables can be converted into characters with the function `as.character()`.

Strings can be converted into factor variables with the function `as.factor()`.

Let us see how these functions work on the example. 


```{r, warning=FALSE, fig.height=5, fig.width=5}
czynniki <- as.factor(koty_ptaki$gatunek)
str(czynniki)
napisy <- as.character(czynniki)
str(napisy)
```
---

# Frequency distribution tables

What if we wanted to present the relationship between two qualitative characteristics?
We could do that using the function `table()` (subsequent variables should be given as arguments).


```{r, eval=FALSE}
table(auta2012$Kraj.pochodzenia, auta2012$Waluta)
```

We could also use the function `xtabs()` which is bit more convenient to use. 

The first argument of that function is the formula with the following syntax `~ zmienna_1 + .. + zmienna_n`. It begins with a tilde and contains variables separated by the sign of plus. The second argument is a data frame which should include the variables listed in the formula. 

The result is a contingency table with number of dimensions equal to the number of variables in the formula. 

For example, if we juxtapose the country of origin and currency we get a frequency distribution table containing 32 rows and 8 columns. Lack of any names in the first row of the table corresponds to the `NA` value of the country of origin.

```{r, warning=FALSE, fig.height=5, fig.width=5}
(krajWaluta <- xtabs( ~ Kraj.pochodzenia + Waluta, auta2012))
```

---

# Frequency distribution tables

Frequency distribution tables are not data frames.

When they contain only two variables they indeed look like data frames - they have rows and columns.
Yet they must be something different because when a contingency table concerns three or more variables, the resulting contingency table has more than two dimensions. 

The function `as.data.frame` serves to transform multidimensional tables into data frames.
It produces the so-called sparse contingency matrix in which first columns describe all the combinations of variable factors and the last column describes frequency distribution of individual combinations of factors. 



```{r, warning=FALSE, fig.height=5, fig.width=5}
xt <- xtabs(~Kraj.pochodzenia+Waluta, auta2012)
xt <- as.data.frame(xt)
# We print only those combinations that are in fact represented in our data
xt[xt$Freq > 0, ]
```

---

# Transformation of quantitative variables into qualitative variables

We can frequently facilitate understanding of quantitative data by dividing variables into ranges. Such ranges are themselves qualitative variables. 

You can convert a qualitative variable into a quantitative variable using the function `cut()`. Its first argument is a quantitative variable and its second argument is number of ranges to be created or border points of these ranges. 

In the example presented below we will transform the variable `waga` from the data set `koty_ptaki` into four rages: 0-1, 1-10, 10-100 i 100-1000. The created variable will be then added to the data set `koty_ptaki` under the name `wagaKategoria`. 



```{r, warning=FALSE, fig.height=5, fig.width=5}
koty_ptaki$waga
koty_ptaki$wagaKategoria <- cut(koty_ptaki$waga, c(0,1,10,100,1000))
table(koty_ptaki$wagaKategoria)
```
---

# Frequency distribution tables

We will use the newly created variable to present graphically the statistics for a pair of qualitative variables. We will juxtapose weight and group variables. 

Then we will apply the function `mosaicplot()` to the two-dimensional table. 

It draws a so-called mosaic plot which simultaneously presents multiple relationships. 
Firstly, it shows columns `Kot` and `Ptak`.
Their width corresponds to the proportions of the values in the data set (their number is almost equal and for that reason the width of the columns is also almost equal).
Secondly, height of rows corresponds to the relative share of particular values in a given column.
In the `Kot` column the weight range 10-100 is domineering, while in the `Ptak` column it is the range 1-10, which is marked with blue. 

This is one of the ways in which we can present conditional distributions. It is very useful although it requires some training in reading.
You will be able to find more information about mosaic plots and other methods of presenting two qualitative variables in the episode 3.  



```{r, warning=FALSE, fig.height=5, fig.width=5}
(druzynaWaga <- xtabs(~druzyna + wagaKategoria, koty_ptaki))

mosaicplot(druzynaWaga, las=2, col=c("green", "blue", "grey", "black"))
```

---

# Order and names of factors

The lexicographic order is the default order of the factors. When we create diagrams we usually present values in the order described by the attribute `levels`. 


```{r, warning=FALSE, fig.height=5, fig.width=5}
levels(auta2012$Rodzaj.paliwa)
boxplot(Rok.produkcji ~ Rodzaj.paliwa, auta2012, las=2)
```

---

# Order and names of factors

The default order can be altered. One of the ways in which we can specify the order of factors is to place the argument levels in the function `factor()`. 
The factors will be listed in the order indicated in that argument. 


```{r, warning=FALSE, fig.height=5, fig.width=5}
levels(auta2012$Skrzynia.biegow)
auta2012$Skrzynia.biegow <- factor(auta2012$Skrzynia.biegow, 
                                levels=c("manualna","", "automatyczna"))
levels(auta2012$Skrzynia.biegow)
```

---

# Order and names of factors

If you wish to sort the levels with respect to certain quantitative value, you can use a very convenient function `reorder()`. 
Its arguments are a vector with a factor variable, a vector with any variable and a function.
For each group defined by the factor variable and for values determined by the second argument the value of the function -the second argument - is specified.
Then the factors are sorted in accordance with the order of the results of the third function. 

In the following example types of fuel are ordered by the average year of manufacture of cars running on a certain type of fuel. 
As you could expect, more "modern" fuels are used in newer cars. 


 

```{r, warning=FALSE, fig.height=5, fig.width=5}
auta2012$Rodzaj.paliwa.posortowany <- reorder(auta2012$Rodzaj.paliwa, 
                                              auta2012$Rok.produkcji, 
                                              mean)

boxplot(Rok.produkcji ~ Rodzaj.paliwa.posortowany, auta2012, las=2)
```

---

# Order and names of factors

We can change not only order of factors but also their names. The easiest way to do that is to use the function `levels()` as illustrated by the following example.  

```{r, warning=FALSE, fig.height=5, fig.width=5}
levels(auta2012$Rodzaj.paliwa)
levels(auta2012$Rodzaj.paliwa) <- c("", "B", "B+C", "B+L", "E", "H", "I", "L", "D", "W")
levels(auta2012$Rodzaj.paliwa)
```


---


# Exercises

+ Divide the variable `Rok.produkcji` from the data set `auta2012` into the following ranges: 1900-1990, 1991-1995, 1996-2000, 2001-2005, 2006-2010, 2011-2012 and the variable `Przebieg.w.km` into ranges: 0-1000, 1001-10 000, 10 001-100 000, 100 001 - 1000 000, 1000 000 - 10 000 000.

+	Create a frequency distribution table for 
the two newly created variables. 

+	Present the table graphically. 

You can see sample answers at: https://rawgit.com/pbiecek/MOOC/master/0_dane/9_zadania.html

