---
title: "Potokowe przetwarzanie danych"
author: "pogRomcy danych"
date: "sezon 1 / odcinek 19 <br><br> Przemysław Biecek @ Uniwersytet Warszawski<br><br><br>Naciśnij `A` by zamienić slajdy na ciągły tekst. <br> Naciśnij `T` by wyświetlić spis treści."
output:
  slidy_presentation:
    includes:
      in_header: ../tracking.html
    highlight: default
    css: ../style.css
    font_adjustment: 0
    footer: "pogRomcy danych / przetwarzanie / potoki"

---

# O czym jest ten odcinek

Przetwarzanie danych składa się najczęściej z wielu kroków. Dane się filtruje, sortuje, grupuje, podsumowuje, znów filtruje, łączy się z innymi itd.

Taka sekwencja operacji przypomina potok, w którym dane wypływają ze źródła, a następnie trafiają na kolejne etapy przetwarzania.

Relatywnie niedawno do programu R wprowadzono operator pozwalający na łatwe opisywanie takich potoków przetwarzania. Można bez niego żyć, 
ale gdy już się go pozna i zacznie z nim pracować, życie bez niego straci na smaku.

W tym odcinku nauczymy się:

- jak składać ze sobą wywołania funkcji do przetwarzania danych w potoki przetwarzania,
- jakim instrukcjom operator przetwarzania potokowego jest równoważny.

Do ilustracji tych zagadnień wykorzystamy zbiór danych `auta2012` dostępny w pakiecie `PogromcyDanych`.


---

# Przetwarzanie ,,krok po kroku''

Jak już wspomnieliśmy analiza danych przez większość czasu polega na przetwarzaniu danych w tą i z powrotem.

Przyjrzyjmy się przykładowej serii operacji. Zaczniemy od danych o wszystkich ofertach sprzedaży samochodów,
odfiltrujemy samochody, które nie są Volkswagenami, pozostałe samochody posortujemy po cenie. Następnie pozostawimy tylko Golfy IV o przebiegu poniżej 50000 km. 

Poniższa instrukcja nie jest najkrótszą z możliwych, celowo została rozciągnięta by łatwiej było przedstawić zalety potoków.

```{r, warning=FALSE, message=FALSE}
library(PogromcyDanych)
library(dplyr)
# tylko volkswagen
tylkoVolkswagen <- filter(auta2012, 
                          Marka == "Volkswagen")
# posortowane
posortowaneVolkswagen <- arrange(tylkoVolkswagen, 
                                 Cena.w.PLN)
# tylko Golf VI
tylkoGolfIV <- filter(posortowaneVolkswagen, 
                      Model == "Golf", Wersja == "IV")
# tylko z małym przebiegiem
tylkoMalyPrzebieg <- filter(tylkoGolfIV, 
                            Przebieg.w.km < 50000)
```

Ta sekwencja operacji tworzy cztery pomocnicze zbiory danych: 
`tylkoVolkswagen`, `posortowaneVolkswagen`, `tylkoGolfIV`, `tylkoMalyPrzebieg`.

Jeżeli potrzebujemy tylko ostatniego, to pozostałe wyłącznie zaśmiecają pamięć, najlepiej byłoby je od razu usunąć lub w ogóle nie tworzyć.

---

# Przetwarzanie ,,na wielką cebulkę''

Ponieważ w R wyniki jednej funkcji można przekazać do innej funkcji, to również wymienione operacje można złożyć w jedną wielką cebulkę.

W jedno olbrzymie wywołanie funkcji w funkcji przekazujące wyniki jednej funkcji bezpośrednio do kolejnej. 

Taka wielka cebulka wyglądałaby następująco.

```{r, warning=FALSE}
tylkoMalyPrzebieg <- 
  filter(
    filter(
      arrange(
        filter(
          auta2012, 
          Marka == "Volkswagen"), 
        Cena.w.PLN), 
      Model == "Golf", Wersja == "IV"), 
    Przebieg.w.km < 50000)
```

W tym rozwiązaniu nie są tworzone zbędne zmienne, ale sam zapis jest bardzo nieczytelny.

Nawet stosując wcięcia trudno nam zauważyć, które argumenty są do której funkcji.

Gdy przetwarzanie jest bardziej złożone to i taki blok może się jeszcze bardziej rozrastać, a tym samym trudniej będzie zrozumieć co się w kodzie dzieje.

---

# Przetwarzanie potokowe

Rozwiązaniem tego problemu jest stosowanie specjalnego operatora do przetwarzania potokowego `%>%`. Ten operator pochodzi z pakietu `magrittr`  (cytując z jego dokumentacji: *to be pronounced with a sophisticated french accent*)  i jest dostępny po włączeniu pakietu `dplyr` (jako pakiet zależny).

Jak działa ten operator?

Przekazuje lewą stronę operatora jako pierwszy argument prawej strony tego operatora.

Tak więc instrukcja ` a %>% f(b) ` jest równoważna instrukcji` f(a, b)`.

Ta prosta sztuczka pozwala znacząco skrócić zapis i uczynić go znacznie czytelniejszym.

```{r, warning=FALSE}
tylkoMalyPrzebieg <- 
  auta2012 %>%                                  # weź dane o autach
  filter(Marka == "Volkswagen") %>%             # pozostaw tylko Volkswageny
  arrange(Cena.w.PLN) %>%                       # posortuj malejąco po cenie
  filter(Model == "Golf", Wersja == "IV") %>%   # pozostał tylko Golfy VI
  filter(Przebieg.w.km < 50000)                 # pozostał tylko auta o małym przebiegu

head(tylkoMalyPrzebieg)
```

---

# Przetwarzanie potokowe - jak to czytać

Jak czytać taki fragment?

Jest to znacznie prostsze ponieważ argumenty są blisko nazw funkcji, możemy więc czytać opis przetwarzania zdanie po zdaniu.

Przedstawiony przykład można czytać następująco.

Weź zbiór danych `auta2012`, 

następnie zastosuj funkcję `filter` pozostawiając tylko auta `Marka == "Volkswagen"`,

następnie posortuj auta malejąco wzdłuż zmiennej `Cena.w.PLN`,

następnie zastosuj funkcję `filter` pozostawiając tylko auta o modelu Golf w wersji IV,

następnie zastosuj funkcję `filter` pozostawiając tylko auta o przebiegu poniżej 50 tys. km.

Zapis z operatorem `%>%` jest w wielu sytuacjach znacznie czytelniejszy i będziemy z niego często korzystać przy przetwarzaniu danych.

```{r, eval=FALSE}
tylkoMalyPrzebieg <- 
  auta2012 %>%                                 
  filter(Marka == "Volkswagen") %>%            
  arrange(Cena.w.PLN) %>%                      
  filter(Model == "Golf", Wersja == "IV") %>%  
  filter(Przebieg.w.km < 50000)                
```

# Wszystko płynie

Jeżeli chcielibyśmy otrzymać pełny przepływ w czytaniu od góry na dół potoku, to zamiast operatora przypisania `<-` możemy wykorzystać operator `->` o identycznym znaczeniu a różniący się tylko kolejnością argumentów.

W poniższym kodzie zostanie wykonane przetwarzanie a w ostatnim kroku wynik zostanie przypisany do zmiennej `tylkoMalyPrzebieg`.

```{r, eval=FALSE}
  auta2012 %>%                                 
  filter(Marka == "Volkswagen") %>%            
  arrange(Cena.w.PLN) %>%                      
  filter(Model == "Golf", Wersja == "IV") %>%  
  filter(Przebieg.w.km < 50000) ->
tylkoMalyPrzebieg 
```

# Co można zrobić z potokiem

Operator `%>%` jest najczęściej wykorzystywany w pracy z funkcjami z pakietów `dplyr` i `ggvis`, ale można go oczywiście stosować również do innych funkcji. 
Koniec końców, jedyne co robi, to przekazuje swój lewy argument jako pierwszy argument wyrażenia po prawej stronie.

Przykładowo, aby wykorzystać funkcję `dim()` do sprawdzenia wymiarów ramki `tylkoMalyPrzebieg`.

```{r, eval=FALSE}
tylkoMalyPrzebieg %>% dim()
```

Aby wyświetlić kilka pierwszych wierszy z ramki danych `tylkoMalyPrzebieg`.

```{r, eval=FALSE}
tylkoMalyPrzebieg %>% head()
```

Jeżeli chcielibyśmy przekazać zbiór danych z lewej strony operatora `%>%` w inne miejsce niż pierwszy argument, Również możemy to zrobić. Miejsce w które ma być wstawiony argument należy w tym celu zamarkować znakiem kropki `.`.

W poniższym przykładzie używamy funkcji `lm()`, podajemy jako pierwszy argument formułę, a jako drugi argument zbiór danych. W tym przykładzie, ponieważ zbiór danych to `.`, to będzie za niego wstawiony zbiór `tylkoMalyPrzebieg` (lewa strona operatora `%>%`).
 
```{r}
tylkoMalyPrzebieg %>% lm(Cena.w.PLN ~ Przebieg.w.km, .)
```

---

# Zadania

* Użyj operatora `%>%` by ze zbioru danych `auta2012` wybrać tylko 10 najtańszych aut marki Rolls-Royce.
* Użyj operatora `%>%` by ze zbioru danych `auta2012` wybrać 5 Volkswagenów o największych silnikach.
 
 Przykładowe odpowiedzi znajdują się na stronie https://rawgit.com/pbiecek/MOOC/master/0_dane/9_zadania.html

