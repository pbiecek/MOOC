---
title: "Reformatowanie i przerzucanie danych [tidyr]"
author: "pogRomcy danych"
date: "sezon 1 / odcinek 24 <br><br> Wszelkie prawa zastrzeżone.<br> Wykorzystanie możliwe wyłącznie za zgodą autora.  <br><br><br><br>Naciśnij `A` by zamienić slajdy na ciągły tekst. <br> Naciśnij `T` by wyświetlić spis treści."
output:
  slidy_presentation:
    includes:
      in_header: ../tracking.html
    highlight: default
    css: ../style.css
    font_adjustment: 0
    footer: "pogRomcy danych / przetwarzanie / formatowanie"

---

# O czym jest ten odcinek

Dane najczęściej są przedstawiane w postaci tabelarycznej. Jednak mogą być w tej tabeli różnie sformatowane. Wyróżnia się między innymi reprezentacje szeroką danych, wąską danych i reprezentacje mieszane.

Po co taka róznorodność? Otóż w zalezności od tego co z danymi chcemy zrobić czasem lepiej je mieć w takiej czy innej postaci. Pakiet `tidyr` udostępnia funkcje, aby szybko i wygodnie przechodzić z jednego sposobu reprezentacji na drugi.

W tym odcinku nauczymy się

- Jak przejść z wąskiej postaci na szeroką
- Jak przejść z szerokiej postaci do wąskiej

Do ilustracji tych zagadnień wykorzystamy dwa zbiory danych. Pierwszy, to zbiór danych `kidney` z pakietu `PBImisc`, pozwoli nam na ilustracje przejścia z formatu szerokiego na wąski. Drugi zbiór danych to dane z Eurostatu, które pobierzemy z użyciem pakietu `SmarterPoland`. Pozwolą one zilustrować przejście z reprezentacji wąskiej danych na szeroką.

---

# Dane o pracy nerki

Aby zilustrować czym jest szeroka reprezentacja danych i jak przejść z niej na wąską reprezetnację wykorzystamy zbiór danych `kidney` z pakietu `PBImisc`. Ten pakiet nie jest dostępny wraz z bazową wersją R. Należy go doinstalować funkcją `install.packages()` (informacja o tym jak to zrobić jest w odcinku 2). Po instalacji włączymy ten pakiet. Do zbioru danych `kidney` dodajemy kolumnę z `id` pacjenta.

```{r, warning=FALSE, message=FALSE}
library(PBImisc)
kidney$id <- rownames(kidney)
```

Następnie ze zbioru `kidney` wybierzemy kilka interesujących nas kolumn. Każdy wiersz w tym zbiorze danych opisuje jednego pacjenta. W kolumnie `therapy` znajduje się zmienna jakościowa o trzech poziomach a w kolumnach MDRD7 ... MDRD60 znajdują sie pomiary sprawności nerki (mierzone współczynnikiem MDRD) w dniach 7, 30, oraz miesiącach 3, 6, 12, 24, 36 i 60 po przeszczepie.

Do wyboru interesujących nas zmiennych wygodnie jest użyć funkcji `select()` z pakietu `dplyr`.

Taką reprezentację danch w której kolejne pomiary MDRD opisane są przez kolejne kolumny nazywa się reprezntacją szeroką. Im więcej punktów pomiarowych dla MDRD tym więcej kolumn w zbiorze danych.

```{r, warning=FALSE, message=FALSE}
library(dplyr)
kidney_wybrane <- kidney %>% 
  dplyr::select(id, therapy, MDRD7:MDRD60)

head(kidney_wybrane)
```

---

# Dane o pracy nerki - postać wąska

Czym w tkim razie jest postać wąska? Łatwiej to wyjasnić na przykładzie. 

Użyjemy funkcji `gather()` z pakietu `tidyr`. Pierwszym argumentem jest ramka danych w postaci szerokiej.
Kolejne dwa argumenty (w poniższym przykłądzie to `time` i `MDRD`) to nazwy zmiennych, które w nowym zbiorze danych będą opisywały klucze i wartości. Pozostałe argumentyto lista kolumn, które mają być przekształcone w reprezentację wąską (tutaj są to wszystkie MDRD...).

Wynikiem jest reprezntacja wąska, w której kolejne pomiary MDRD zostały przedstawione za pomocą różnych wierszy. W reprezentacji wąskiej w kolumnie `time` znajduje się nazwa kolumny z oryginalnego zbioru danych, a w kolimnie `MDRD` znajdują się wartości.

Zbiór danych `kidney_wybrane` miał 334 wiersze i 10 kolumn a zbiór danych `kidney_waska` ma 2672 wiersze i 4 kolumny. Każdy z 334 pacjentów jest opisany przez 8 wierszy, każdy wiersz dla innego puntku pomiarowego MDRD.

```{r, warning=FALSE, message=FALSE}
library(tidyr)

kidney_waska <- gather(kidney_wybrane, time, MDRD, MDRD7:MDRD60)
head(kidney_waska)
```
---

# Dane o pracy nerki - postać wąska

Warto zauważyć, że zmienne nie wymienione w funkcji `gather()` (w tym przykładzie to zmienne `id` oraz `therapy`) zostaną pozostawione w ramce danych, nie będą skonwertowane na postać wąską.

```{r, warning=FALSE, message=FALSE}
kidney_waska %>% filter(id=="1")
```

---

# Dane z EuroStatu

Do ilustracj transforamcji z postaci wąskiej na szeroką wykorzystamy dane z Eurostatu. Dane w Eurostacie są przechowywane z kilkoma wymiarami, na takich danych wygodniej się pracuje, gdy są one w postaci wąskiej. Jednak gdy przychodzi o wyświetlania tych danych na ekranie wygodniej jest je przekształcić na postać szeroką.

Do ilustracji tych funkcji wykorzystamy zbiór danych z Eurostatu o popularności transpostu w różnych krajach. Te dane są w tabeli `tsdtr210` na serwerach Eurostat.
Do pobrania tych danych użyjemy funkcji `getEurostatRCV()` z pakietu `SmarterPoland`.

```{r, warning=FALSE, message=FALSE}
library(SmarterPoland)
tsdtr210 <- getEurostatRCV("tsdtr210")
head(tsdtr210)
```

Pobrane dane są w postaci wąskiej. Kolumna `geo` określa kraj, kolumna `time` określa rok, kolumna `vehicle` rodzaj transportu a kolumna `value` oopuarność danego rodzaju transportu w określonym kraju w określonym roku.

---

# Z postaci wąskiej do szerokiej

Aby przejść z postaci wąskiej do postaci szerokie, można użyć funkcji `spread()`.

Jej pierwszym argumentem jest ramka z danymi w postaci wąskiej. Kolejne dwie zmienne określają kolumnę w której przechowywane są klucze i wartości. 

Funkcja `spread()` konwertuje ramkę danych w ten sposób, że wartości drugiej kolumny wejściowego zbioru danych stają się nazwami kolumn wyjściowego zbioru danych.

W poniższym przykładzie zmienna `time` jest wskazana jako klucz, a więc wartości tej zmiennej staną się nazwami kolumn w nowym zbiorze danych. Zmienna `value` jest wskazana jako wartości i to ona wypełni nowe kolumny.

Pozostałe kolumny, w tym przypakdu `vehicle` i 'geo', pozostają w niezmienionej postaci.

Wyświetlmy wiersze spełniające warunek `geo == "PL"`. Jak widzimy wynikowy zbiór danych `szeroka` ma 13 kolumn opisujących popularność różnych środków transportu w kolejnych latach.

```{r, warning=FALSE, message=FALSE}
szeroka <- spread(tsdtr210, time, value)

# wyświetlmy wiersze dla Polski
szeroka %>% filter(geo == "PL")
```

# Z postaci wąskiej do szerokiej

Dane z Eurostatu miały więcej wymiarów i każdy z nich może być użyty do stworzenia nowych kolumn. Przykładowo w poniższym przykłądzie do rozszerzenia ramki danych wykorzystamy zmienną `geo`.

```{r, warning=FALSE, message=FALSE}
szeroka2 <- spread(tsdtr210, geo, value)

# wyświetlmy wiersze dla roku 2010
szeroka2 %>% filter(time == "2010")
```

---

# Z szerokiej do wąskiej

Proces przechodzenia z wąskiej postaci do szerokiej i z szerokiej do wąskiej jest odwracalny. Pokażmy jak z powrotem, przejść z postaci szerokiej do wąskiej, za pomocą funkcji `gather()`.

Poniżej pierwszy argument jest przekazany za pomocą operatora `%>%`, kolejne dwa określają nazwy nowych kolumn w których zapisane będą klucze i wartości. Trzeci argument to opis kolumn, które mają być zamienione na postać wąską.

```{r, warning=FALSE, message=FALSE}
szeroka %>% 
  gather(rok, wartosc, -geo, -vehicle) %>%
  head()
```

---

# Sklejanie kolumn

Zdarza się, że wartości z kilku kolumn chcemy skleić ze sobą w jedną kolumnę.
Można to zrobić funkcją `unite()`.

Pierwszy argument tej funkcji to ramka danych. Drugi to nazwa kolumny, która zostanie utworzona przez połączenie kolumn, które sa pozostałymi argumentami. Argument `sep` określa co ma rozdzielać wartości w połączonych kolumnach.

W przykładzie poniżej w zbiorze danych `tsdtr210` tworzymy nową kolumnę o nazwie `panstwo_rok`, której wartości powstaną przez połaczenie wartości w kolumnach `geo` i `time` rozdzielając je znakiem `:`.

```{r, warning=FALSE, message=FALSE}
unite(tsdtr210, panstwo_rok, geo, time, sep=":") %>%
  head()
```

---

# Rozszcezpianie kolumn

Operację odwrotną do sklejania, a więc rozcinanie kolumn można wykonać funkcją `separate()`.

Przedstawimy działanie tej funkcji na przykładzie sztucznego zbioru danych z dwoma kolumnamy - datą i id.

```{r, warning=FALSE, message=FALSE}
df <- data.frame(daty = c("2004-01-01", "2012-04-15", "2006-10-29", "2010-03-03"),
                 id = 1:4)
df
```

Pierwszym argumentem funkcji `separate()` jest ramka danych, którą chcemy przekształcić. Drugim argumentem jest nazwa kolumny, którą chcemy rozszczepić. Trzecim argumentem jest wektor napisów, któ®e będą nazwami nowych - rozszczepionych kolumn. Czwarty argument to separator - znak, który rozszczepi kolumny. Poniżej przedstawiamy przykłąd, w którym koulnę `daty` ze zbioru danych `df` rozszczepiamy na wartości rozdizelone znakiem `-`. Poszczególne skłądowe będą nowiły nazwy rok, miesiąc i dzień.

```{r, warning=FALSE, message=FALSE}
separate(df, daty, c("rok", "miesiac", "dzien"), "-")
```

---

# Zadania

* W bazie danych Eurostatu o nazwie `prc_ppp_ind` zbierane są informacje o średniej sile nabywczej.
Odczytaj te dane funkcją `getEurostatRCV()` a następnie zamień z postaci wąskiej do szerokiej.
* Ze zbioru danych `kidney` wybierz tylko kolumny MDRD12, MDRD24, MDRD36, MDRD60 a następnie zamień je z pozstaci szerokiej do wąskiej.
* W zbiorze danych `kidney` niezgodności w antygenach AB i DR są opsisane przez kolumny `discrepancy.AB` i `discrepancy.DR`. Zamień je w jedną kolumnę o nazwie `discrepancy` gdzie obie niezgodności są sklejone i separowane znakiem `_`.

Przykładowe odpowiedzi znajdują się na stronie https://rawgit.com/pbiecek/MOOC/master/0_dane/9_zadania.html

