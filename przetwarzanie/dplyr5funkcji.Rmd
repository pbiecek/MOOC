---
title: "Eksploracja / dplyr"
output:
  html_document:
    toc: yes
---

Przygotowując dane do analiz musimy wykonać dwa ważne kroki
* określić w jakim formacie i jakie dane potrzebujemy
* określić w jaki sposób dane przetworzyć do tego formatu.

Oba kroki są ważne!
Dplyr pozwala na wykonanie większości pracy polegającej na przygotowaniu danych za pomocą pięciu mechanizmów, które można ze sboą składać.
Poznamy te pięć klocków poniżej i zobaczymy jak je łączyć ze sobą

Dplyr nie jest jedynym pakietem, wspierającym analizy danych. Ale jest bardzo bardzo szybki i jest kompleksowym rozwiązaniem. Dlatego nauczymy się go używać.

# Wczytanie danych

Każdy wiersz zbioru danych `auta2012` opisuje jedną ofertę sprzedaży auta. Każda kolumna opisuje jedną cechę / właściwość tej oferty.

```{r, warning=FALSE, message=FALSE}
library(SmarterPoland)
head(auta2012)
```

# Ramki i tabele danych

Dane surowe mogą mieć różną postać. Mogą to być korpusy tekstów, nagrań audio lub video.
Jednak w analizie danych często sprawodza się dane do postaci tabelarycznej, ponieważ większość funkcji oczekuje takiego formatu danych.

Podstawowym typem danych, przechowujących dane w postaci tabelarycznej jest typ `data.frame`. Dane mają postać tabeli w której w każdej kolumnie są wartości tego samego typu (np. liczby, napisy, wartości logiczne).

Odwołując się do elementów tabeli korzysta się ze składni `tabela[ktore_wiersze, ktore_kolmny]`.

Przykładowo, wybranie 3 wiersza z naszej tabeli liczb wyglądałoby tak

```{r, warning=FALSE}
auta2012[3,]
```

A wiersze od 3 do 5?

```{r, warning=FALSE}
auta2012[3:5,]
```

Podobnie możemy odwoływać się do kolumn i obu wymiarów jednocześnie.

```{r, warning=FALSE}
auta2012[3:5, 2:4]
```

## Zadania
[TODO:]
do tych ćwiczeń inny zbiór danych,
mniejszy o kilku kolumnach i kilkunastu wierszach
może coś ściągnięte z GUS ? 


# Filtrowanie danych
Używając funkcji filter() można przefiltrować dane, zostawiając tylko te, któ®e spełniają określony warunek (jeden lub kilka).
Pierwszym argumentem tej funkcji jest ramka danych,
kolejne argumenty, a może być ich jeden lub więcej) to warunki logiczne, które muszę być spełnione aby dany wiersz trafił do wyniki.

Jeżeli chcemy pozostawić tylko samochody marki Porsche, możemy uzyć warunku `Marka == 'Porsche'`.

```{r, warning=FALSE}
tylkoPorsche <-
  filter(auta2012,
       Marka == "Porsche")
```

Memy określać jednocześnie więcej warunków.
Na przykłąd tylko samochody Audi o silnikach o liczbie koni mechanicnzych przekraczających 300 możemy odfiltrować w następujący sposób.

```{r, warning=FALSE}
tylkoPorscheZDużymSilnikiem <-
  filter(auta2012,
       Marka == "Porsche",
       KM > 300)
```

## Zadania
+ Ze zbioru danych `auta2012` pozostaw tylko samochody o wieku do pięciu lat (czyli o roku produkcji > 2007). Nazwij ten wynikowy zbiór danych `mlodeAuta`
+ Z przed chwilą stworzonego zbioru danych `mlodeAuta` wybierz tylko Fiaty 500. Ile jest takich aut? 
(wymiary ramki danych możesz sprawdzić funkcją dim())


# Sortowanie danych
Bardzo często w zbiorze danych jesteśmy zainteresowani znalezieniem tych wierszy, któych warotści są największe lub najmniejsze. 

Również by sprawdzić, czy dane przyjmują sensowe wartości, często sprawdzamy ekstraema, największe i najmenijsze przypadku, by ocenić czy one przyjmują rozsądne wartości.

Do sortowania, bardzo przydatna jest funkcja `arrange()`, która jako pierwszy argument przyjmuje ramkę danych a jako kolejne argumenty przyjmuje zmienne, wzdłuż których dane są sortowane.

Posortujmy dane wzdłuż ceny w polskich złotych.

```{r, warning=FALSE}
posortowanePorsche <-
  arrange(tylkoPorscheZDużymSilnikiem, 
        Cena.w.PLN)
```

Aby zobaczyć jakie wiersza są pierwsze a jakie są ostatnie w tym zbiorze danych, możemy użyć funkcji `head()` i `tail()`. Domyślnie wybiranych jest pierwszych lub ostatnich 6 wierszy. Ale ustawiając drugi argument można wyświetlać więcej lub mniej wierszy.

```{r, warning=FALSE}
head(posortowanePorsche)

tail(posortowanePorsche)
```

Jeżeli wskażemy więcej niż jedną zmienną do sortowania, to w pierwszym kroku sortowanie odbędzie się wzdłuż pierwszej zmiennej, a w przypadku remisu (takich samych wartości) w drugim kropku wzdłuż drugiej zmiennej.

W poniższym przypadku w pierwszym kroku sortujemy po Modelu auta, gdy samochody mają ten sam model to ich kolwjność jest określona przez drugą zmienną, czyli w tym przypadku cenie.

Model jest nazwą i w tym przypadku jest sortowany w kolejności alfabetycznej.

```{r, warning=FALSE}
head(
   arrange(tylkoPorscheZDużymSilnikiem, 
        Model, Cena.w.PLN)
  ) 
```

Domyślnie dane sortowane są rosnąco. Jeżeli chcemy zrminić kolejnośc sortowania i sortować malejąco, to należy daną zmienną opakować funkcją `desc()` jak na poniższym przykładzie.

```{r, warning=FALSE}
head(
   arrange(tylkoPorscheZDużymSilnikiem, 
        Model, desc(Cena.w.PLN))
  ) 
```

## Zadania
* Posortuj auta wzdłuż wielkości silnika (liczby koni mechanicznych, kolumna KM lub pojemności skokowej, kolumna Pojemnosc.skokowa). Które marki mają najwięszke silniki?
* Wybierz tylko auta marki 'Rolls-Royce' i posortuj je po cenie.


# Przetwarzanie potokowe
Analiza danych przez większość czasu polega na przetwarzaniu danych w tą i zpowrotem.

Zobaczmy taką serię operacji, która zaczyna się od wszystkich samochodów,
odfiltrowuje się tylko Volkswageny, sortuje po cenie, pozostawia tylko Golfy IV oraz samochody o przebiegu poniżej 50000 km.

```{r, warning=FALSE}
tylkoVolkswagen <- filter(auta2012, 
                          Marka == "Volkswagen")
posortowaneVolkswagen <- arrange(tylkoVolkswagen, 
                                 Cena.w.PLN)
tylkoGolfIV <- filter(posortowaneVolkswagen, 
                      Model == "Golf", Wersja == "IV")
tylkoMalyPrzebieg <- filter(tylkoGolfIV, 
                            Przebieg.w.km < 50000)
```

Ta sekwencja operacji tworzy cztery pomocnicze zbiory danych: 
tylkoVolkswagen, posortowaneVolkswagen, tylkoGolfIV, tylkoMalyPrzebieg.
Ale one zaśmiecają jedynie przestrzeń nazw.

Te operacje można złożyć w jeną wileką cebulkę, 
przekazując wyniki jednej funkcji bezpośrednio do kolejnej. 
Taka wielka cebulka wyglądałaby następująco.

```{r, warning=FALSE}
tylkoMalyPrzebieg <- 
  filter(
    filter(
      arrange(
        filter(
          auta2012, 
          Marka == "Volkswagen"), 
        Cena.w.PLN), 
      Model == "Golf", Wersja == "IV"), 
    Przebieg.w.km < 50000)
```

W tym rozwiązaniu nie są tworzone zbędna nazwy zmiennych, ale sam zapis jest bardzo nieczytelny.

Nawet stosując wcięcia trudno nam zauważyć, które argumenty są do której funkcji.
Taki blok może się jeszcze bardziej rozrastać i tym trudniej będzie zrozumieć co się w tym kodzie dzieje.

Rozwiązaniem tego problemu jest stosowanie specjalnego operatora do przetwarzania potokowaegp `%>%`. Ten operator pochodzi z pakietu `magrittr`  (to be pronounced with a sophisticated french accent)  i jest dostępny po włączeniu pakietu `dplyr`.

Jak działa ten operator?
Przekazuje lewą stronę operatora jako pierwszy argument prawej strony tego operatora
` a %>% f(b) `
jest równoważne
` f(a, b) `

Ta prosta sztuczka pozwala znacząco skrócić zapis i uczynić go znacznie czytelniejszym.

```{r, warning=FALSE}
tylkoMalyPrzebieg <- 
  auta2012 %>%
  filter(Marka == "Volkswagen") %>%
  arrange(Cena.w.PLN) %>%
  filter(Model == "Golf", Wersja == "IV") %>%
  filter(Przebieg.w.km < 50000)
```

Ten framgnet kodu można czytać w następujący sposób.
Weź zbiór danych `auta2012`, 
następnie zasosuj funkcję `filter` pozostawiając tylko auta `Marka == "Volkswagen"`,
następnie posortuj auta malejąco wzdłuż zmiennej `Cena.w.PLN`,
następnie zastosuj funkcję `filter` pozostawiając tylko auta o modelu Golf w wersji IV,
następnie zastosuj funkcję `filter` pozostawiając tylko auta o przebiegu poniżej 50 tys km.

Znacznie czytelniejszy zapis. 
Będziemy z operatora `%>%` często korzystać przy wstępnym przetwarzaniu danych.

## Zadania
* Użyj operatora `%>%` by ze zbioru danych `auta2012` wybrać tylko 10 najtańszych aut marki Rolls-Royce.
* Użyj operatora `%>%` by ze zbioru danych `auta2012` wybrać 5 Viklswagenów o największych silnikach.


# Wybór zmiennych
Duże zbiory danych potrafią mieć tysiące zmiennych. Często jednak pracujemy tylko na kilku z nich, a pozostałe głównie nam przeszkadzają.

Funkcja `select()` pozwala w prosty sposób wybrać kilka potrzebnych zmiennych z dużego zbioru danych. Pierwszym argumentem jest ramka danych, a kolejne to zmienne, które chcemy pozostawić. 

Zmienne, które chcemy pozostawić można wskazywać na kilka sposobów. Przećwiczmy je na zbiorze `auta2012`. W tym zbiorze dostępne są następujące dane.
```{r, warning=FALSE}
colnames(auta2012)
```

Przypuśćmy, że chcemy wybrać tylko Cenę, Markę, Model, Wersję i Przebieg.w.km. Wystarczy te zmienne wymienić jako argumenty funkcji select.
```{r, warning=FALSE}
auta2012 %>%
  select(Cena.w.PLN, Marka, Model, Wersja, Przebieg.w.km)
```

Jeżeli chcemy usunąć kilka kolumn, można co tego wykorzystać operator -. 
A robi się to tak.
Usuwamy 9 wskazanych kolumn.
```{r, warning=FALSE}
auta2012 %>%
  select(-Cena, -Waluta, -Brutto.netto, 
         -Kraj.aktualnej.rejestracji, -Kraj.pochodzenia,
         -Pojazd.uszkodzony, -Skrzynia.biegow,
         -Status.pojazdu.sprowadzonego, -Wyposazenie.dodatkowe)
```

Można również wybierać kolumny, których nazwy pasują do pewnego wzorca.
Przykład poniżej wybiera wszystkie nazwy kolumn, które w nazwie mają wzorzec `aj`.
```{r, warning=FALSE}
auta2012 %>%
  select(matches("aj"))
```

## Zadania
* Wybierz tylko samochody marki Volvo, posortuj je po pojemności skokowej, a następnie wyświetl tylko trzy kolumny: Markę, Cenę.w.PLN i Kolor.

# Wyliczanie nowych zmiennych
Nie zawsze w zbiorze danych są dokładnie te zmienne, których potrzebujemy.
Czasem musimy je policzyć, służy do tego funkcja o wdzięcznej nazwie `mutate()`.

Policzmy najpierw wiek auta. Dane były zbierane w roku 2012, więc wiek auta to różnica pomiędzy rokiem produkcji, rokiem 2012 plus 1.
```{r, warning=FALSE}
autaZWiekiem <- auta2012 %>%
  mutate(Wiek.auta = 2013 - Rok.produkcji)
autaZWiekiem %>% 
  select(Wiek.auta, Rok.produkcji)
```

Drugą użyteczną zmienną to cena brutto. Teraz część aut ma cenę brutto a część netto. To utrudnia porównania. Przeliczmy wszystkie ceny na brutto dodając 23\% tam gdzie podana jest cena netto.

```{r, warning=FALSE}
autaZCenaBrutto <- auta2012 %>%
  mutate(Cena.brutto = Cena.w.PLN * ifelse(Brutto.netto == "brutto", 1, 1.23))
autaZCenaBrutto %>% 
  select(Cena.brutto, Brutto.netto, Cena.w.PLN)
```

Funkcja `ifelse()` jako wynik zwraca drugi lub trzegi argument w zależności od tego czy pierwszy argument jest prawdziwy czy nie.

W jednym wykonaniu funkcji `mutate()` można podać kilka transformacji.

```{r, warning=FALSE}
autaZWiekiemIBrutto <- auta2012 %>%
  mutate(Wiek.auta = 2013 - Rok.produkcji,
         Cena.brutto = Cena.w.PLN * ifelse(Brutto.netto == "brutto", 1, 1.23))

autaZWiekiemIBrutto %>% 
  select(Cena.brutto, Brutto.netto, Cena.w.PLN, Wiek.auta, Rok.produkcji)
```

## Zadania
* Policz średni przebieg na rok, dzieląc przebieg przez wieka auta.
* Poza koniem mechanicznym inną ciekawą jednostką mocy jest koń parowy (jednostka HP). Jeden koń mechanicnzy to 0.9863 konia parowego. Utwórz nową zmienną, która przedstawi moc aut w koniach parowych (btw: Wikipedia zna jeszcze kilka innych ciekawych jednostek mocy).

# Agregaty
Zbiór danych `ceny2012` zawiera szczegółowe informacje o parametrach każdej oferty sprzedaży. Często z takich zbiorów danych interesują nas pewne statystyki agregujące informacje ze zbioru danych. 

Przykładem może być średnia cena, zmienność, czyli odchylenie standardowe ceny,
połówkowy przebieg czy liczba obserwacji. 

Takie agregaty możemy wyznaczyć funkcją `summarise()`.
Jako pierwszy argument podajemy zbiór danych a jako kolejne wskazujemy statystyki / agregaty, które chcemy wyznaczyć z tego zbioru danych. 

```{r, warning=FALSE}
auta2012 %>%
  summarise(sredniaCena = mean(Cena.w.PLN),
            sdCena = sqrt(var(Cena.w.PLN)),
            medianaPrzebiegu = median(Przebieg.w.km, na.rm=TRUE),
            liczba = n())
```

Funkcja `mean()` wyznacza średnią, funkcja `var()` wyznacza wariancję a pierwiasterk z waiancji jest odchyleniem standardowym, funkcja `median()` wyznacza liczbę obserwacji w grupie.

Nie wszystkie wartości są podane dla wszystkich zmiennych. Jeżeli jakaś wartość nei zostałą podana, to w zbiorze danych jest ona zakodowana jako NA - (ang. Not Available) brakująca wartość.

Jeżeli w zmiennej są wartości brakujące, to argument `na.rm=TRUE` oznacza, że wynik ma być wyznaczony po usunięciu wartości brakujących.

## Zadania
* Policz sumaryczny przebieg wszystkich samochodów
* Wybierz tylko samochody marki 'Rolls-Royce' i policz ich średni przebieg oraz średnią cenę.


# Grupowanie

Jedną z bardziej użytecznych funkcji jest możliwość liczenia agregatów w grupach. 
Aby określić jedną lub kilka zmiennych grupujących można wykorzystać funkcję `group_by()`.

W poniższym przykładzie liczymy agregaty osobno dla każdej grupy określonej przez `Rodzaj.paliwa`.

```{r, warning=FALSE}
auta2012 %>%
  group_by(Rodzaj.paliwa) %>%
  summarise(medianaCeny = median(Cena.w.PLN, na.rm=TRUE),
            medianaPrzebieg = median(Przebieg.w.km, na.rm=TRUE),
            liczba = n())
```

Na agregatach możemy pracować tak jak na zwykłych ramkach danych. Możemy przekazać je dalej do funkcji które sortują, wybierają lub zmieniają zmienne.

W poniższym przykładzie sortujemy agregaty po średniej cenie.

```{r, warning=FALSE}
auta2012 %>%
  group_by(Rodzaj.paliwa) %>%
  summarise(medianaCeny = median(Cena.w.PLN, na.rm=TRUE),
            medianaPrzebieg = median(Przebieg.w.km, na.rm=TRUE),
            liczba = n()) %>%
  arrange(medianaCeny)
```

Grupować można po kilku zmiennych, w tym przypadku agregaty liczone są w każdym podzbiorze zmiennych.

Prześledźmy teraz większy przykład przetwarzania skłądającego się z kilku kroków.
Będziemy chcieli zobaczyć średnie ceny i przebiegi różnych pięcioletnich modeli Volkswagena w zależności od rodzaju paliwa.

Zaczniemy od wybrania tylko pięcioletnich Volkswagenów.

```{r, warning=FALSE}
auta2012 %>%
  filter(Rok.produkcji == 2007, Marka == "Volkswagen")
```

Następnie do potoku dodamy informację, że chcemy grupować po modelach i po rodzajach paliwa. 
Dla każdej grupy chcemy wyznaczyć średnią cenę, średni przebieg i liczbę samochodów w takiej grupie.

```{r, warning=FALSE}
auta2012 %>%
  filter(Rok.produkcji == 2007, Marka == "Volkswagen") %>%
  group_by(Model, Rodzaj.paliwa) %>%
  summarise(sredniaCena = mean(Cena.w.PLN, na.rm=TRUE),
            sredniPrzebieg = mean(Przebieg.w.km, na.rm=TRUE),
            liczba = n())
```

Kolejność wierszy jest przypadkowa co utrudnia jakiekolwiek porównania.
Posortujmy więc te wyniki po zmiennej Model i zmiennej sredniaCena, którą przed chwilą wyznaczyliśmy.

Dzięki temu auta będą posortowane po modelu a w ramach tego samego modelu po średniej cenie.

```{r, warning=FALSE}
auta2012 %>%
  filter(Rok.produkcji == 2007, Marka == "Volkswagen") %>%
  group_by(Model, Rodzaj.paliwa) %>%
  summarise(sredniaCena = mean(Cena.w.PLN, na.rm=TRUE),
            sredniPrzebieg = mean(Przebieg.w.km, na.rm=TRUE),
            liczba = n()) %>%
  arrange(Model, sredniaCena) 
```

Niektóre średnie są dosyć przypadkowe, ponieważ w grupie było tylko jedno / dwa auta. 
Usuńmy grupy, w których było mniej niż 10 samochodów, dzięki temu te średnie będą bardziej wiarygodne.

```{r, warning=FALSE}
auta2012 %>%
  filter(Rok.produkcji == 2007, Marka == "Volkswagen") %>%
  group_by(Model, Rodzaj.paliwa) %>%
  summarise(sredniaCena = mean(Cena.w.PLN, na.rm=TRUE),
            sredniPrzebieg = mean(Przebieg.w.km, na.rm=TRUE),
            liczba = n()) %>%
  arrange(Model, sredniaCena) %>%
  filter(liczba > 10)
```

## Zadania
* Wybierz pięcioletnie Golfy i sprawdź czy średnia cena zależy od kraju aktualnej rejestracji. W tym celu pogrupuj po zmiennej Kraj.aktualnej.rejestracji i w każdej grupie policz średnią.
* Wybierz tylko Peugeoty 206 i policz średnią cenę w zależności od roku produkcji. Posortuj te grupy po roku produkcji.


# Challenge
To zadanie wykonaj samodzielnie. Będzie ono oceniane oraz wyślemy Ci uwagi co do napisanego kodu.

Wybierz jendą markę i model samochodu. Sprawdź jaka jest cena w zależności od rocznika i w zależności tego, czy auto jest białego koloru.

W salonach białe samochody są czasem tańsze, zobacz czy ta różnica jest widoczna w autach używanych.

