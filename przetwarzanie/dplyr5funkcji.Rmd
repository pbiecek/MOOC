---
title: "Eksploracja / dplyr"
output:
  html_document:
    toc: yes
---

Przygotowując dane do analiz musimy wykonać dwa ważne kroki
* określić w jakim formacie i jakie dane potrzebujemy
* określić w jaki sposób dane przetworzyć do tego formatu.

Oba kroki są ważne!
Dplyr pozwala na wykonanie większości pracy polegającej na przygotowaniu danych za pomocą pięciu mechanizmów, które można ze sboą składać.
Poznamy te pięć klocków poniżej i zobaczymy jak je łączyć ze sobą

Dplyr nie jest jedynym pakietem, wspierającym analizy danych. Ale jest bardzo bardzo szybki i jest kompleksowym rozwiązaniem. Dlatego nauczymy się go używać.

# Wczytanie danych

Każdy wiersz zbioru danych `auta2012` opisuje jedną ofertę sprzedaży auta. Każda kolumna opisuje jedną cechę / właściwość tej oferty.

```{r, warning=FALSE}
library(SmarterPoland)
head(auta2012)
```

## Ramki i tabele danych

Dane surowe mogą mieć różną postać. Mogą to być korpusy tekstów, nagrań audio lub video.
Jednak w analizie danych często sprawodza się dane do postaci tabelarycznej, ponieważ większość funkcji oczekuje takiego formatu danych.

Podstawowym typem danych, przechowujących dane w postaci tabelarycznej jest typ `data.frame`. Dane mają postać tabeli w której w każdej kolumnie są wartości tego samego typu (np. liczby, napisy, wartości logiczne).

Odwołując się do elementów tabeli korzysta się ze składni `tabela[ktore_wiersze, ktore_kolmny]`.

Przykładowo, wybranie 3 wiersza z naszej tabeli liczb wyglądałoby tak

```{r, warning=FALSE}
auta2012[3,]
```

A wiersze od 3 do 5?

```{r, warning=FALSE}
auta2012[3:5,]
```

Podobnie możemy odwoływać się do kolumn i obu wymiarów jednocześnie.

```{r, warning=FALSE}
auta2012[3:5, 2:4]
```


## Filtrowanie danych
Używając funkcji filter() można przefiltrować dane, zostawiając tylko te, któ®e spełniają określony warunek (jeden lub kilka).
Pierwszym argumentem tej funkcji jest ramka danych,
kolejne argumenty, a może być ich jeden lub więcej) to warunki logiczne, które muszę być spełnione aby dany wiersz trafił do wyniki.

Jeżeli chcemy pozostawić tlyko samochody marki Porsche, możemy uzyć warunku `Marka == 'Porsche'`.

```{r, warning=FALSE}
tylkoPorsche <-
  filter(auta2012,
       Marka == "Porsche")
```

Memy określać jednocześnie więcej warunków.
Na przykłąd tylko samochody Audi o silnikach o liczbie koni mechanicnzych przekraczających 300 możemy odfiltrować w następujący sposób.

```{r, warning=FALSE}
tylkoPorscheZDużymSilnikiem <-
  filter(auta2012,
       Marka == "Porsche",
       KM > 300)
```

### Zadania:
+ Ze zbioru danych `auta2012` pozostaw tylko samochody o wieku do pięciu lat (czyli o roku produkcji > 2007). Nazwij ten wynikowy zbiór danych `mlodeAuta`
+ Z przed chwilą stworzonego zbioru danych `mlodeAuta` wybierz tylko Fiaty 500. Ile jest takich aut? 
(wymiary ramki danych możesz sprawdzić funkcją dim())


## Sortowanie danych
Bardzo często w zbiorze danych jesteśmy zainteresowani znalezieniem tych wierszy, któych warotści są największe lub najmniejsze. 

Również by sprawdzić, czy dane przyjmują sensowe wartości, często sprawdzamy ekstraema, największe i najmenijsze przypadku, by ocenić czy one przyjmują rozsądne wartości.

Do sortowania, bardzo przydatna jest funkcja `arrange()`, która jako pierwszy argument przyjmuje ramkę danych a jako kolejne argumenty przyjmuje zmienne, wzdłuż których dane są sortowane.

Posortujmy dane wzdłuż ceny w polskich złotych.

```{r, warning=FALSE}
posortowanePorsche <-
  arrange(tylkoPorscheZDużymSilnikiem, 
        Cena.w.PLN)
```

Aby zobaczyć jakie wiersza są pierwsze a jakie są ostatnie w tym zbiorze danych, możemy użyć funkcji `head()` i `tail()`. Domyślnie wybiranych jest pierwszych lub ostatnich 6 wierszy. Ale ustawiając drugi argument można wyświetlać więcej lub mniej wierszy.

```{r, warning=FALSE}
head(posortowanePorsche)

tail(posortowanePorsche)
```

Jeżeli wskażemy więcej niż jedną zmienną do sortowania, to w pierwszym kroku sortowanie odbędzie się wzdłuż pierwszej zmiennej, a w przypadku remisu (takich samych wartości) w drugim kropku wzdłuż drugiej zmiennej.

W poniższym przypadku w pierwszym kroku sortujemy po Modelu auta, gdy samochody mają ten sam model to ich kolwjność jest określona przez drugą zmienną, czyli w tym przypadku cenie.

Model jest nazwą i w tym przypadku jest sortowany w kolejności alfabetycznej.

```{r, warning=FALSE}
head(
   arrange(tylkoPorscheZDużymSilnikiem, 
        Model, Cena.w.PLN)
  ) 
```

Domyślnie dane sortowane są rosnąco. Jeżeli chcemy zrminić kolejnośc sortowania i sortować malejąco, to należy daną zmienną opakować funkcją `desc()` jak na poniższym przykładzie.

```{r, warning=FALSE}
head(
   arrange(tylkoPorscheZDużymSilnikiem, 
        Model, desc(Cena.w.PLN))
  ) 
```

### Zadania:
* Posortuj auta wzdłuż wielkości silnika (liczby koni mechanicznych, kolumna KM lub pojemności skokowej, kolumna Pojemnosc.skokowa). Które marki mają najwięszke silniki?
* Wybierz tylko auta marki 'Rolls-Royce' i posortuj je po cenie.


## Przetwarzanie potokowe, `%>%`
```{r, warning=FALSE}
```

## select() (and rename()) [contains, starts_with, ends_with, matches]?
```{r, warning=FALSE}
```
## mutate() (and transmute())
```{r, warning=FALSE}
```


## group_by()
## summarise()
## n()
## first() last()
## summarise()







### Zadania:
+ Sprawdź ile samochodów ma zainstalowany autoalarm **PCH: (oznaczony jako 'autoalarm')**
+ Sprawdź ile samochodów ma lakier w metalicznym kolorze **PCH: (oznaczony jako 'metallic')**

### Odpowiedzi:
+ `r sum(grepl(auta2012$Wyposazenie.dodatkowe.napis, pattern="autoalarm"))`
+ `r sum(grepl(as.character(auta2012$Kolor), pattern="metallic"))`


