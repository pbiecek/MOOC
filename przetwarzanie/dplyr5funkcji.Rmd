---
title: "Eksploracja / dplyr"
output:
  html_document:
    toc: yes
---

Przygotowując dane do analiz musimy wykonać dwa ważne kroki
* określić w jakim formacie i jakie dane potrzebujemy
* określić w jaki sposób dane przetworzyć do tego formatu.

Oba kroki są ważne!
Dplyr pozwala na wykonanie większości pracy polegającej na przygotowaniu danych za pomocą pięciu mechanizmów, które można ze sboą składać.
Poznamy te pięć klocków poniżej i zobaczymy jak je łączyć ze sobą

Dplyr nie jest jedynym pakietem, wspierającym analizy danych. Ale jest bardzo bardzo szybki i jest kompleksowym rozwiązaniem. Dlatego nauczymy się go używać.

# Wczytanie danych

Każdy wiersz zbioru danych `auta2012` opisuje jedną ofertę sprzedaży auta. Każda kolumna opisuje jedną cechę / właściwość tej oferty.

```{r, warning=FALSE, message=FALSE}
library(SmarterPoland)
head(auta2012)
```

## Ramki i tabele danych

Dane surowe mogą mieć różną postać. Mogą to być korpusy tekstów, nagrań audio lub video.
Jednak w analizie danych często sprawodza się dane do postaci tabelarycznej, ponieważ większość funkcji oczekuje takiego formatu danych.

Podstawowym typem danych, przechowujących dane w postaci tabelarycznej jest typ `data.frame`. Dane mają postać tabeli w której w każdej kolumnie są wartości tego samego typu (np. liczby, napisy, wartości logiczne).

Odwołując się do elementów tabeli korzysta się ze składni `tabela[ktore_wiersze, ktore_kolmny]`.

Przykładowo, wybranie 3 wiersza z naszej tabeli liczb wyglądałoby tak

```{r, warning=FALSE}
auta2012[3,]
```

A wiersze od 3 do 5?

```{r, warning=FALSE}
auta2012[3:5,]
```

Podobnie możemy odwoływać się do kolumn i obu wymiarów jednocześnie.

```{r, warning=FALSE}
auta2012[3:5, 2:4]
```

### Zadania:
[TODO:]
do tych ćwiczeń inny zbiór danych,
mniejszy o kilku kolumnach i kilkunastu wierszach
może coś ściągnięte z GUS ? 


## Filtrowanie danych
Używając funkcji filter() można przefiltrować dane, zostawiając tylko te, któ®e spełniają określony warunek (jeden lub kilka).
Pierwszym argumentem tej funkcji jest ramka danych,
kolejne argumenty, a może być ich jeden lub więcej) to warunki logiczne, które muszę być spełnione aby dany wiersz trafił do wyniki.

Jeżeli chcemy pozostawić tylko samochody marki Porsche, możemy uzyć warunku `Marka == 'Porsche'`.

```{r, warning=FALSE}
tylkoPorsche <-
  filter(auta2012,
       Marka == "Porsche")
```

Memy określać jednocześnie więcej warunków.
Na przykłąd tylko samochody Audi o silnikach o liczbie koni mechanicnzych przekraczających 300 możemy odfiltrować w następujący sposób.

```{r, warning=FALSE}
tylkoPorscheZDużymSilnikiem <-
  filter(auta2012,
       Marka == "Porsche",
       KM > 300)
```

### Zadania:
+ Ze zbioru danych `auta2012` pozostaw tylko samochody o wieku do pięciu lat (czyli o roku produkcji > 2007). Nazwij ten wynikowy zbiór danych `mlodeAuta`
+ Z przed chwilą stworzonego zbioru danych `mlodeAuta` wybierz tylko Fiaty 500. Ile jest takich aut? 
(wymiary ramki danych możesz sprawdzić funkcją dim())


## Sortowanie danych
Bardzo często w zbiorze danych jesteśmy zainteresowani znalezieniem tych wierszy, któych warotści są największe lub najmniejsze. 

Również by sprawdzić, czy dane przyjmują sensowe wartości, często sprawdzamy ekstraema, największe i najmenijsze przypadku, by ocenić czy one przyjmują rozsądne wartości.

Do sortowania, bardzo przydatna jest funkcja `arrange()`, która jako pierwszy argument przyjmuje ramkę danych a jako kolejne argumenty przyjmuje zmienne, wzdłuż których dane są sortowane.

Posortujmy dane wzdłuż ceny w polskich złotych.

```{r, warning=FALSE}
posortowanePorsche <-
  arrange(tylkoPorscheZDużymSilnikiem, 
        Cena.w.PLN)
```

Aby zobaczyć jakie wiersza są pierwsze a jakie są ostatnie w tym zbiorze danych, możemy użyć funkcji `head()` i `tail()`. Domyślnie wybiranych jest pierwszych lub ostatnich 6 wierszy. Ale ustawiając drugi argument można wyświetlać więcej lub mniej wierszy.

```{r, warning=FALSE}
head(posortowanePorsche)

tail(posortowanePorsche)
```

Jeżeli wskażemy więcej niż jedną zmienną do sortowania, to w pierwszym kroku sortowanie odbędzie się wzdłuż pierwszej zmiennej, a w przypadku remisu (takich samych wartości) w drugim kropku wzdłuż drugiej zmiennej.

W poniższym przypadku w pierwszym kroku sortujemy po Modelu auta, gdy samochody mają ten sam model to ich kolwjność jest określona przez drugą zmienną, czyli w tym przypadku cenie.

Model jest nazwą i w tym przypadku jest sortowany w kolejności alfabetycznej.

```{r, warning=FALSE}
head(
   arrange(tylkoPorscheZDużymSilnikiem, 
        Model, Cena.w.PLN)
  ) 
```

Domyślnie dane sortowane są rosnąco. Jeżeli chcemy zrminić kolejnośc sortowania i sortować malejąco, to należy daną zmienną opakować funkcją `desc()` jak na poniższym przykładzie.

```{r, warning=FALSE}
head(
   arrange(tylkoPorscheZDużymSilnikiem, 
        Model, desc(Cena.w.PLN))
  ) 
```

### Zadania:
* Posortuj auta wzdłuż wielkości silnika (liczby koni mechanicznych, kolumna KM lub pojemności skokowej, kolumna Pojemnosc.skokowa). Które marki mają najwięszke silniki?
* Wybierz tylko auta marki 'Rolls-Royce' i posortuj je po cenie.


## Przetwarzanie potokowe, `%>%`
Analiza danych przez większość czasu polega na przetwarzaniu danych w tą i zpowrotem.

Zobaczmy taką serię operacji, która zaczyna się od wszystkich samochodów,
odfiltrowuje się tylko Volkswageny, sortuje po cenie, pozostawia tylko Golfy IV oraz samochody o przebiegu poniżej 50000 km.

```{r, warning=FALSE}
tylkoVolkswagen <- filter(auta2012, 
                          Marka == "Volkswagen")
posortowaneVolkswagen <- arrange(tylkoVolkswagen, 
                                 Cena.w.PLN)
tylkoGolfIV <- filter(posortowaneVolkswagen, 
                      Model == "Golf", Wersja == "IV")
tylkoMalyPrzebieg <- filter(tylkoGolfIV, 
                            Przebieg.w.km < 50000)
```

Ta sekwencja operacji tworzy cztery pomocnicze zbiory danych: 
tylkoVolkswagen, posortowaneVolkswagen, tylkoGolfIV, tylkoMalyPrzebieg.
Ale one zaśmiecają jedynie przestrzeń nazw.

Te operacje można złożyć w jeną wileką cebulkę, 
przekazując wyniki jednej funkcji bezpośrednio do kolejnej. 
Taka wielka cebulka wyglądałaby następująco.

```{r, warning=FALSE}
tylkoMalyPrzebieg <- 
  filter(
    filter(
      arrange(
        filter(
          auta2012, 
          Marka == "Volkswagen"), 
        Cena.w.PLN), 
      Model == "Golf", Wersja == "IV"), 
    Przebieg.w.km < 50000)
```

W tym rozwiązaniu nie są tworzone zbędna nazwy zmiennych, ale sam zapis jest bardzo nieczytelny.

Nawet stosując wcięcia trudno nam zauważyć, które argumenty są do której funkcji.
Taki blok może się jeszcze bardziej rozrastać i tym trudniej będzie zrozumieć co się w tym kodzie dzieje.

Rozwiązaniem tego problemu jest stosowanie specjalnego operatora do przetwarzania potokowaegp `%>%`. Ten operator pochodzi z pakietu `magrittr`  (to be pronounced with a sophisticated french accent)  i jest dostępny po włączeniu pakietu `dplyr`.

Jak działa ten operator?
Przekazuje lewą stronę operatora jako pierwszy argument prawej strony tego operatora
` a %>% f(b) `
jest równoważne
` f(a, b) `

Ta prosta sztuczka pozwala znacząco skrócić zapis i uczynić go znacznie czytelniejszym.

```{r, warning=FALSE}
tylkoMalyPrzebieg <- 
  auta2012 %>%
  filter(Marka == "Volkswagen") %>%
  arrange(Cena.w.PLN) %>%
  filter(Model == "Golf", Wersja == "IV") %>%
  filter(Przebieg.w.km < 50000)
```

Ten framgnet kodu można czytać w następujący sposób.
Weź zbiór danych `auta2012`, 
następnie zasosuj funkcję `filter` pozostawiając tylko auta `Marka == "Volkswagen"`,
następnie posortuj auta malejąco wzdłuż zmiennej `Cena.w.PLN`,
następnie zastosuj funkcję `filter` pozostawiając tylko auta o modelu Golf w wersji IV,
następnie zastosuj funkcję `filter` pozostawiając tylko auta o przebiegu poniżej 50 tys km.

Znacznie czytelniejszy zapis. 
Będziemy z operatora `%>%` często korzystać przy wstępnym przetwarzaniu danych.

### Zadania:
* Użyj operatora `%>%` by ze zbioru danych `auta2012` wybrać tylko 10 najtańszych aut marki Rolls-Royce.
* Użyj operatora `%>%` by ze zbioru danych `auta2012` wybrać 5 Viklswagenów o największych silnikach.


## Wybór zmiennych
Duże zbiory danych potrafią mieć tysiące zmiennych. Często jednak pracujemy tylko na kilku z nich, a pozostałe głównie nam przeszkadzają.

Funkcja `select()` pozwala w prosty sposób wybrać kilka potrzebnych zmiennych z dużego zbioru danych. Pierwszym argumentem jest ramka danych, a kolejne to zmienne, które chcemy pozostawić. 

Zmienne, które chcemy pozostawić można wskazywać na kilka sposobów. Przećwiczmy je na zbiorze `auta2012`. W tym zbiorze dostępne są następujące dane.
```{r, warning=FALSE}
colnames(auta2012)
```

Przypuśćmy, że chcemy wybrać tylko Cenę, Markę, Model, Wersję i Przebieg.w.km. Wystarczy te zmienne wymienić jako argumenty funkcji select.
```{r, warning=FALSE}
auta2012 %>%
  select(Cena.w.PLN, Marka, Model, Wersja, Przebieg.w.km)
```

Jeżeli chcemy usunąć kilka kolumn, można co tego wykorzystać operator -. 
A robi się to tak.
Usuwamy 9 wskazanych kolumn.
```{r, warning=FALSE}
auta2012 %>%
  select(-Cena, -Waluta, -Brutto.netto, 
         -Kraj.aktualnej.rejestracji, -Kraj.pochodzenia,
         -Pojazd.uszkodzony, -Skrzynia.biegow,
         -Status.pojazdu.sprowadzonego, -Wyposazenie.dodatkowe)
```

Można również wybierać kolumny, których nazwy pasują do pewnego wzorca.
Przykład poniżej wybiera wszystkie nazwy kolumn, które w nazwie mają wzorzec `aj`.
```{r, warning=FALSE}
auta2012 %>%
  select(matches("aj"))
```

### Zadania:
* Wybierz tylko samochody marki Volvo, posortuj je po pojemności skokowej, a następnie wyświetl tylko trzy kolumny: Markę, Cenę.w.PLN i Kolor.



## mutate() (and transmute())
```{r, warning=FALSE}
```


## group_by()
## summarise()
## n()
## first() last()







### Zadania:
+ Sprawdź ile samochodów ma zainstalowany autoalarm **PCH: (oznaczony jako 'autoalarm')**
+ Sprawdź ile samochodów ma lakier w metalicznym kolorze **PCH: (oznaczony jako 'metallic')**

### Odpowiedzi:
+ `r sum(grepl(auta2012$Wyposazenie.dodatkowe.napis, pattern="autoalarm"))`
+ `r sum(grepl(as.character(auta2012$Kolor), pattern="metallic"))`


